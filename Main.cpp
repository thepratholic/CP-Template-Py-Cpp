{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"cp": {
        "prefix": "cp",
        "body": [
            "// Choose cpp when the time",
            "// limit will for sure give tle in pypy",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
			"#define INF LLONG_MAX",
            "#define fastio ios::sync_with_stdio(false); cin.tie(0);",
            "#define print(arr) for (auto it : arr){cout<<it<<\" \";}cout<<endl;",
            "#define len(arr) arr.size()",
            "#define printf(x) cout << x << endl;",
            "#define printm(map) cout<<\"{\";for(auto it: map){cout<<it.first<<\":\"<<it.second<<\",\";};cout<<\"}\"<<endl;",
            "",
            "// const int MOD = 998244353;",
            "const int MOD = 1e9 + 7;",
            "",
            "int gcd(int a, int b) {",
            "\tif (b == 0) return a;",
            "\treturn gcd(b, a % b);",
            "}",
            "",
            "int lcm(int a, int b) {",
            "\treturn a / gcd(a, b) * b;",
            "}",
            "",
			"// String hashing: sh/shclass, Number: numtheory, SparseTable: SparseTable",
            "// Segment Tree(lazy propogation): SegmentTree, Merge Sort Tree: sorttree",
            "// binary indexed tree: BIT, Segment Tree(point updates): SegmentPoint, Convex Hull: hull, Trie/Treap: Tries",
            "// Combinatorics: pnc, Diophantine Equations: dpheq, Graphs: graphs, DSU: DSU, Geometry: Geometry, FFT: fft",
            "// Persistent Segment Tree: perseg, FreqGraphs: bgraph",
            "// Template : https://github.com/OmAmar106/Template-for-Competetive-Programming",
			"",
            "void solve() {",
            "\tint n; cin >> n;",
            "\tvector<int> L(n);",
            "\tfor (int &x : L) cin >> x;",
            "}",
            "",
            "int32_t main() {",
            "\tfastio",
            "\tint t; cin >> t;",
            "\twhile (t--) solve();",
            "\treturn 0;",
            "}"
        ],
        "description": "cp implementation"
    },
	"numtheory": {
        "prefix": "numtheory",
        "body": [
            "int mod_exp(int base, int exp, int mod = MOD) {",
            "\tint res = 1;",
            "\twhile (exp) {",
            "\t\tif (exp % 2) res = res * base % mod;",
            "\t\tbase = base * base % mod;",
            "\t\texp /= 2;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "vector<vector<int>> matmul(const vector<vector<int>> &A, const vector<vector<int>> &B, int MOD = 1000000007) {",
            "\tint n = A.size(), m = B[0].size(), p = B.size();",
            "\tvector<vector<int>> ans(n, vector<int>(m, 0));",
            "\tfor (int i = 0; i < n; ++i) {",
            "\t\tfor (int j = 0; j < m; ++j) {",
            "\t\t\tfor (int k = 0; k < p; ++k) {",
            "\t\t\t\tans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % MOD;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn ans;",
            "}",
            "",
            "vector<vector<int>> matpow(vector<vector<int>> M, int power, int MOD = 1000000007) {",
            "\tint size = M.size();",
            "\tvector<vector<int>> result(size, vector<int>(size, 0));",
            "\tfor (int i = 0; i < size; ++i) result[i][i] = 1;",
            "\twhile (power) {",
            "\t\tif (power % 2 == 1) result = matmul(result, M, MOD);",
            "\t\tM = matmul(M, M, MOD);",
            "\t\tpower /= 2;",
            "\t}",
            "\treturn result;",
            "}",
            "",
            "vector<int> sieve(int n) {",
            "\tvector<int> primes;",
            "\tvector<bool> isp(n + 1, true);",
            "\tisp[0] = isp[1] = false;",
            "\tfor (int i = 2; i <= n; ++i) {",
            "\t\tif (isp[i]) {",
            "\t\t\tprimes.push_back(i);",
            "\t\t\tfor (int j = i * i; j <= n; j += i) isp[j] = false;",
            "\t\t}",
            "\t}",
            "\treturn primes;",
            "}",
            "",
            "bool is_prime(int n) {",
            "\tif (n <= 1) return false;",
            "\tif (n <= 3) return true;",
            "\tif (n % 2 == 0 || n % 3 == 0) return false;",
            "\tfor (int i = 5; i * i <= n; i += 6) {",
            "\t\tif (n % i == 0 || n % (i + 2) == 0) return false;",
            "\t}",
            "\treturn true;",
            "}",
            "",
            "vector<int> all_factors(int n) {",
            "\tvector<int> small, large;",
            "\tfor (int i = 1; i * i <= n; i += (n & 1) ? 2 : 1) {",
            "\t\tif (n % i == 0) {",
            "\t\t\tsmall.push_back(i);",
            "\t\t\tif (i != n / i) large.push_back(n / i);",
            "\t\t}",
            "\t}",
            "\treverse(large.begin(), large.end());",
            "\tsmall.insert(small.end(), large.begin(), large.end());",
            "\treturn small;",
            "}",
            "",
            "vector<int> sieve_unique(int N) {",
            "\tvector<int> mini(N);",
            "\tiota(mini.begin(), mini.end(), 0);",
            "\tfor (int i = 2; i < N; ++i) {",
            "\t\tif (mini[i] == i) {",
            "\t\t\tfor (int j = 2 * i; j < N; j += i) mini[j] = i;",
            "\t\t}",
            "\t}",
            "\treturn mini;",
            "}",
            "",
            "vector<int> prime_factors(int k, const vector<int>& Lmini) {",
            "\tvector<int> ans;",
            "\twhile (k != 1) {",
            "\t\tans.push_back(Lmini[k]);",
            "\t\tk /= Lmini[k];",
            "\t}",
            "\treturn ans;",
            "}",
			"",
			"int mod_inverse(int a, int mod = MOD) {",
            "\treturn mod_exp(a, mod - 2, mod);",
            "}",
			""
        ],
        "description": "numtheory implementation"
    },
	"shclass": {
        "prefix": "shclass",
        "body": [
            "int HMOD = 2147483647;",
            "int HBASE1 = rand() % HMOD;",
            "int HBASE2 = rand() % HMOD;",
            "",
            "class Hashing {",
            "public:",
            "\tint mod, base1, base2, _len;",
            "\tvector<int> f_hash, f_pow, s_hash, s_pow;",
            "",
            "\tHashing(const string& s, int mod = HMOD, int base1 = HBASE1, int base2 = HBASE2) : mod(mod), base1(base1), base2(base2) {",
            "\t\t_len = s.size();",
            "\t\tf_hash.assign(_len + 1, 0);",
            "\t\tf_pow.assign(_len + 1, 1);",
            "\t\ts_hash.assign(_len + 1, 0);",
            "\t\ts_pow.assign(_len + 1, 1);",
            "",
            "\t\tfor (int i = 0; i < _len; ++i) {",
            "\t\t\tf_hash[i + 1] = (base1 * f_hash[i] + s[i]) % mod;",
            "\t\t\ts_hash[i + 1] = (base2 * s_hash[i] + s[i]) % mod;",
            "\t\t\tf_pow[i + 1] = base1 * f_pow[i] % mod;",
            "\t\t\ts_pow[i + 1] = base2 * s_pow[i] % mod;",
            "\t\t}",
            "\t}",
            "",
            "\tpair<int, int> hashed(int start, int stop) {",
            "\t\tint hash1 = (f_hash[stop] - f_pow[stop - start] * f_hash[start] % mod + mod) % mod;",
            "\t\tint hash2 = (s_hash[stop] - s_pow[stop - start] * s_hash[start] % mod + mod) % mod;",
            "\t\treturn {hash1, hash2};",
            "\t}",
            "",
            "\tpair<vector<int>, vector<int>> get_hashes(int length) {",
            "\t\tvector<int> f_res, s_res;",
            "\t\tfor (int i = 0; i <= _len - length; ++i) {",
            "\t\t\tf_res.push_back((f_hash[i + length] - f_pow[length] * f_hash[i] % mod + mod) % mod);",
            "\t\t\ts_res.push_back((s_hash[i + length] - s_pow[length] * s_hash[i] % mod + mod) % mod);",
            "\t\t}",
            "\t\treturn {f_res, s_res};",
            "\t}",
            "};"
        ],
        "description": "shclass implementation"
    },
	"SparseTable": {
        "prefix": "sparsetable",
        "body": [
            "class SparseTable {",
            "public:",
            "\tint n;",
            "\tvector<vector<int>> table;",
            "",
            "\tstatic int func(int a, int b) {",
            "\t\treturn gcd(a, b);",
            "\t}",
            "",
            "\tSparseTable(const vector<int>& arr) {",
            "\t\tn = arr.size();",
            "\t\tint log = log2(n) + 1;",
            "\t\ttable.assign(n, vector<int>(log, 0));",
            "\t\tbuild(arr);",
            "\t}",
            "",
            "\tvoid build(const vector<int>& arr) {",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\ttable[i][0] = arr[i];",
            "\t\t}",
            "\t\tfor (int j = 1; (1 << j) <= n; ++j) {",
            "\t\t\tfor (int i = 0; i + (1 << j) <= n; ++i) {",
            "\t\t\t\ttable[i][j] = func(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tint query(int L, int R) {",
            "\t\tint j = log2(R - L + 1);",
            "\t\treturn func(table[L][j], table[R - (1 << j) + 1][j]);",
            "\t}",
            "};"
        ],
        "description": "SparseTable implementation"
    },
    "SegmentTree": {
        "prefix": "segmenttree",
        "body": [
            "class SegmentTree {",
            "public:",
            "\tint n;",
            "\tvector<int> tree;",
            "\tvector<int> lazy_add;",
            "\tvector<int> lazy_set;",
            "\tint NO_ASSIGNMENT = LLONG_MIN;",
            "\tSegmentTree(vector<int>& arr) {",
            "\t\tn = arr.size();",
            "\t\ttree.assign(4 * n, 0);",
            "\t\tlazy_add.assign(4 * n, 0);",
            "\t\tlazy_set.assign(4 * n, NO_ASSIGNMENT);",
            "\t\tbuild_tree(1, 0, n - 1, arr);",
            "\t}",
            "\tstatic int func(int a, int b) {",
            "\t\treturn a + b;",
            "\t}",
            "\tvoid build_tree(int node, int start, int end, vector<int>& arr) {",
            "\t\tif (start == end) {",
            "\t\t\ttree[node] = arr[start];",
            "\t\t} else {",
            "\t\t\tint mid = start + (end - start) / 2;",
            "\t\t\tbuild_tree(2 * node, start, mid, arr);",
            "\t\t\tbuild_tree(2 * node + 1, mid + 1, end, arr);",
            "\t\t\ttree[node] = func(tree[2 * node], tree[2 * node + 1]);",
            "\t\t}",
            "\t}",
            "\tvoid propagate_lazy(int node, int start, int end) {",
            "\t\tint current_range_size = (end - start + 1);",
            "\t\tif (lazy_set[node] != NO_ASSIGNMENT) {",
            "\t\t\ttree[node] = lazy_set[node] * current_range_size;",
            "\t\t\tif (start != end) {",
            "\t\t\t\tlazy_set[2 * node] = lazy_set[node];",
            "\t\t\t\tlazy_set[2 * node + 1] = lazy_set[node];",
            "\t\t\t\tlazy_add[2 * node] = 0;",
            "\t\t\t\tlazy_add[2 * node + 1] = 0;",
            "\t\t\t}",
            "\t\t\tlazy_set[node] = NO_ASSIGNMENT;",
            "\t\t}",
            "\t\tif (lazy_add[node] != 0) {",
            "\t\t\ttree[node] += lazy_add[node] * current_range_size;",
            "\t\t\tif (start != end) {",
            "\t\t\t\tlazy_add[2 * node] += lazy_add[node];",
            "\t\t\t\tlazy_add[2 * node + 1] += lazy_add[node];",
            "\t\t\t}",
            "\t\t\tlazy_add[node] = 0;",
            "\t\t}",
            "\t}",
            "\tvoid update(int node, int start, int end, int l, int r, int value, bool is_add) {",
            "\t\tpropagate_lazy(node, start, end);",
            "\t\tif (start > r || end < l) {",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (start >= l && end <= r) {",
            "\t\t\tif (is_add) {",
            "\t\t\t\ttree[node] += value * (end - start + 1);",
            "\t\t\t\tif (start != end) {",
            "\t\t\t\t\tlazy_add[2 * node] += value;",
            "\t\t\t\t\tlazy_add[2 * node + 1] += value;",
            "\t\t\t\t}",
            "\t\t\t} else {",
            "\t\t\t\ttree[node] = value * (end - start + 1);",
            "\t\t\t\tif (start != end) {",
            "\t\t\t\t\tlazy_set[2 * node] = value;",
            "\t\t\t\t\tlazy_set[2 * node + 1] = value;",
            "\t\t\t\t\tlazy_add[2 * node] = 0;",
            "\t\t\t\t\tlazy_add[2 * node + 1] = 0;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = start + (end - start) / 2;",
            "\t\tupdate(2 * node, start, mid, l, r, value, is_add);",
            "\t\tupdate(2 * node + 1, mid + 1, end, l, r, value, is_add);",
            "\t\ttree[node] = func(tree[2 * node], tree[2 * node + 1]);",
            "\t}",
            "\tint query(int node, int start, int end, int l, int r) {",
            "\t\tpropagate_lazy(node, start, end);",
            "\t\tif (start > r || end < l) {",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tif (start >= l && end <= r) {",
            "\t\t\treturn tree[node];",
            "\t\t}",
            "\t\tint mid = start + (end - start) / 2;",
            "\t\treturn func(query(2 * node, start, mid, l, r), query(2 * node + 1, mid + 1, end, l, r));",
            "\t}",
            "\tvoid range_update(int l, int r, int value, bool is_add = true) {",
            "\t\tupdate(1, 0, n - 1, l, r, value, is_add);",
            "\t}",
            "\tint range_query(int l, int r) {",
            "\t\treturn query(1, 0, n - 1, l, r);",
            "\t}",
            "\tvector<int> to_list() {",
            "\t\tvector<int> result(n);",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\tresult[i] = range_query(i, i);",
            "\t\t}",
            "\t\treturn result;",
            "\t}",
            "};"
        ],
        "description": "SegmentTree implementation"
    },
	"BIT": {
        "prefix": "bit",
        "body": [
            "class BIT {",
            "public:",
            "\tint n;",
            "\tvector<int> bit;",
            "",
            "\tBIT(vector<int>& arr) {",
            "\t\tn = arr.size();",
            "\t\tbit = arr;",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\tint j = i | (i + 1);",
            "\t\t\tif (j < n) bit[j] += bit[i];",
            "\t\t}",
            "\t}",
            "",
            "\tvoid update(int idx, int x) {",
            "\t\twhile (idx < n) {",
            "\t\t\tbit[idx] += x;",
            "\t\t\tidx |= idx + 1;",
            "\t\t}",
            "\t}",
            "",
            "\tint query(int end) {",
            "\t\tint x = 0;",
            "\t\twhile (end > 0) {",
            "\t\t\tx += bit[end - 1];",
            "\t\t\tend &= end - 1;",
            "\t\t}",
            "\t\treturn x;",
            "\t}",
            "",
            "\tint findkth(int k) {",
            "\t\tint idx = -1;",
            "\t\tfor (int d = 63 - __builtin_clzll(n); d >= 0; --d) {",
            "\t\t\tint right_idx = idx + (1LL << d);",
            "\t\t\tif (right_idx < n && k >= bit[right_idx]) {",
            "\t\t\t\tidx = right_idx;",
            "\t\t\t\tk -= bit[idx];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn idx + 1;",
            "\t}",
            "};"
        ],
        "description": "BIT implementation"
    },
	"SegmentPoint": {
        "prefix": "segmentpoint",
        "body": [
            "class SegmentTree {",
            "public:",
            "\tint n;",
            "\tvector<int> tree;",
            "",
            "\tstatic int func(int a, int b) {",
            "\t\treturn max(a, b);",
            "\t}",
            "",
            "\tSegmentTree(const vector<int>& data) {",
            "\t\tn = data.size();",
            "\t\ttree.resize(2 * n);",
            "\t\tbuild(data);",
            "\t}",
            "",
            "\tvoid build(const vector<int>& data) {",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\ttree[n + i] = data[i];",
            "\t\t}",
            "\t\tfor (int i = n - 1; i > 0; --i) {",
            "\t\t\ttree[i] = func(tree[i * 2], tree[i * 2 + 1]);",
            "\t\t}",
            "\t}",
            "",
            "\tvoid update(int pos, int value) {",
            "\t\tpos += n;",
            "\t\ttree[pos] = value;",
            "\t\twhile (pos > 1) {",
            "\t\t\tpos /= 2;",
            "\t\t\ttree[pos] = func(tree[2 * pos], tree[2 * pos + 1]);",
            "\t\t}",
            "\t}",
            "",
            "\tint query(int left, int right) {",
            "\t\tleft += n;",
            "\t\tright += n;",
            "\t\tint max_val = LLONG_MIN;",
            "\t\twhile (left < right) {",
            "\t\t\tif (left % 2 == 1) {",
            "\t\t\t\tmax_val = func(max_val, tree[left]);",
            "\t\t\t\tleft++;",
            "\t\t\t}",
            "\t\t\tif (right % 2 == 1) {",
            "\t\t\t\tright--;",
            "\t\t\t\tmax_val = func(max_val, tree[right]);",
            "\t\t\t}",
            "\t\t\tleft /= 2;",
            "\t\t\tright /= 2;",
            "\t\t}",
            "\t\treturn max_val;",
            "\t}",
            "};"
        ],
        "description": "SegmentPoint implementation"
    },
	"hull": {
        "prefix": "hull",
        "body": [
            "class Line {",
            "public:",
            "\tint m, b;",
            "\tLine(int m = 0, int b = INF) : m(m), b(b) {}",
            "\tint operator()(int x) const {",
            "\t\treturn m * x + b;",
            "\t}",
            "};",
            "",
            "class ConvexHull {",
            "public:",
            "\tint n;",
            "\tvector<Line> seg;",
            "\tvector<int> lo, hi;",
            "",
            "\tConvexHull(int n = 1000000) : n(n), seg(4 * n, Line()), lo(4 * n), hi(4 * n) {",
            "\t\tbuild(1, 1, n);",
            "\t}",
            "",
            "\tvoid build(int i, int l, int r) {",
            "\t\tstack<tuple<int, int, int>> stack;",
            "\t\tstack.emplace(i, l, r);",
            "\t\twhile (!stack.empty()) {",
            "\t\t\tauto [idx, left, right] = stack.top();",
            "\t\t\tstack.pop();",
            "\t\t\tlo[idx] = left;",
            "\t\t\thi[idx] = right;",
            "\t\t\tseg[idx] = Line(0, INF);",
            "\t\t\tif (left == right) continue;",
            "\t\t\tint mid = (left + right) / 2;",
            "\t\t\tstack.emplace(2 * idx + 1, mid + 1, right);",
            "\t\t\tstack.emplace(2 * idx, left, mid);",
            "\t\t}",
            "\t}",
            "",
            "\tvoid insert(Line L) {",
            "\t\tint pos = 1;",
            "\t\twhile (true) {",
            "\t\t\tint l = lo[pos], r = hi[pos];",
            "\t\t\tif (l == r) {",
            "\t\t\t\tif (L(l) < seg[pos](l)) seg[pos] = L;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tint m = (l + r) / 2;",
            "\t\t\tif (seg[pos].m < L.m) swap(seg[pos], L);",
            "\t\t\tif (seg[pos](m) > L(m)) {",
            "\t\t\t\tswap(seg[pos], L);",
            "\t\t\t\tpos = 2 * pos;",
            "\t\t\t} else {",
            "\t\t\t\tpos = 2 * pos + 1;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tint query(int x) {",
            "\t\tint i = 1, res = seg[i](x), pos = i;",
            "\t\twhile (true) {",
            "\t\t\tint l = lo[pos], r = hi[pos];",
            "\t\t\tres = min(res, seg[pos](x));",
            "\t\t\tif (l == r) return res;",
            "\t\t\tint m = (l + r) / 2;",
            "\t\t\tpos = (x < m) ? 2 * pos : 2 * pos + 1;",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "hull implementation"
    },
	"tries": {
        "prefix": "tries",
        "body": [
            "vector<int> left_child = {0}, right_child = {0}, treap_keys = {0};",
            "vector<double> treap_prior = {0.0};",
            "",
            "int treap_create_node(int key) {",
            "\ttreap_keys.push_back(key);",
            "\ttreap_prior.push_back((double)rand() / RAND_MAX);",
            "\tleft_child.push_back(0);",
            "\tright_child.push_back(0);",
            "\treturn treap_keys.size() - 1;",
            "}",
            "",
            "pair<int, int> treap_split(int root, int key) {",
            "\tint left_pos = 0, right_pos = 0;",
            "\twhile (root) {",
            "\t\tif (key < treap_keys[root]) {",
            "\t\t\tleft_child[right_pos] = right_pos = root;",
            "\t\t\troot = left_child[root];",
            "\t\t} else {",
            "\t\t\tright_child[left_pos] = left_pos = root;",
            "\t\t\troot = right_child[root];",
            "\t\t}",
            "\t}",
            "\tint left = right_child[0], right = left_child[0];",
            "\tright_child[left_pos] = left_child[right_pos] = right_child[0] = left_child[0] = 0;",
            "\treturn {left, right};",
            "}",
            "",
            "int treap_merge(int left, int right) {",
            "\tint where = 0, pos = 0;",
            "\twhile (left && right) {",
            "\t\tif (treap_prior[left] > treap_prior[right]) {",
            "\t\t\tright_child[where] = where = left;",
            "\t\t\tleft = right_child[left];",
            "\t\t} else {",
            "\t\t\tleft_child[where] = where = right;",
            "\t\t\tright = left_child[right];",
            "\t\t}",
            "\t}",
            "\tright_child[where] = left ? left : right;",
            "\tint node = right_child[0];",
            "\tright_child[0] = 0;",
            "\treturn node;",
            "}",
            "",
            "int treap_insert(int root, int key) {",
            "\tauto [left, right] = treap_split(root, key);",
            "\treturn treap_merge(treap_merge(left, treap_create_node(key)), right);",
            "}",
            "",
            "class Trie {",
            "public:",
            "\tunordered_map<char, Trie*> children;",
            "\tbool is_end = false;",
            "",
            "\tvoid add(const string& word) {",
            "\t\tTrie* node = this;",
            "\t\tfor (char ch : word) {",
            "\t\t\tif (!node->children.count(ch)) {",
            "\t\t\t\tnode->children[ch] = new Trie();",
            "\t\t\t}",
            "\t\t\tnode = node->children[ch];",
            "\t\t}",
            "\t\tnode->is_end = true;",
            "\t}",
            "",
            "\tbool contains(const string& word) const {",
            "\t\tconst Trie* node = this;",
            "\t\tfor (char ch : word) {",
            "\t\t\tif (!node->children.count(ch)) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t\tnode = node->children.at(ch);",
            "\t\t}",
            "\t\treturn node->is_end;",
            "\t}",
            "",
            "\tvoid remove(const string& word) {",
            "\t\tvector<Trie*> nodes;",
            "\t\tTrie* node = this;",
            "\t\tfor (char ch : word) {",
            "\t\t\tif (!node->children.count(ch)) return;",
            "\t\t\tnodes.push_back(node);",
            "\t\t\tnode = node->children[ch];",
            "\t\t}",
            "\t\tnode->is_end = false;",
            "\t\tfor (int i = nodes.size() - 1; i >= 0; --i) {",
            "\t\t\tchar ch = word[i];",
            "\t\t\tif (!nodes[i]->children[ch]->is_end && nodes[i]->children[ch]->children.empty()) {",
            "\t\t\t\tdelete nodes[i]->children[ch];",
            "\t\t\t\tnodes[i]->children.erase(ch);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tries implementation"
    },
	"pnc": {
        "prefix": "pnc",
        "body": [
            "class Factorial {",
            "public:",
            "\tint mod;",
            "\tvector<int> f, g;",
            "",
            "\tFactorial(int N, int mod) : mod(mod) {",
            "\t\tN += 1;",
            "\t\tf.resize(N, 1);",
            "\t\tg.resize(N, 1);",
            "\t\tfor (int i = 1; i < N; i++) {",
            "\t\t\tf[i] = f[i - 1] * i % mod;",
            "\t\t}",
            "\t\tg[N - 1] = pow_mod(f[N - 1], mod - 2, mod);",
            "\t\tfor (int i = N - 2; i >= 0; i--) {",
            "\t\t\tg[i] = g[i + 1] * (i + 1) % mod;",
            "\t\t}",
            "\t}",
            "",
            "\tint pow_mod(int a, int b, int m) {",
            "\t\tint res = 1;",
            "\t\twhile (b) {",
            "\t\t\tif (b & 1) res = res * a % m;",
            "\t\t\ta = a * a % m;",
            "\t\t\tb >>= 1;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "\tint fac(int n) { return f[n]; }",
            "\tint fac_inv(int n) { return g[n]; }",
            "",
            "\tint combi(int n, int m) {",
            "\t\tif (m == 0) return 1;",
            "\t\tif (n < m || m < 0 || n < 0) return 0;",
            "\t\treturn f[n] * g[m] % mod * g[n - m] % mod;",
            "\t}",
            "",
            "\tint permu(int n, int m) {",
            "\t\tif (n < m || m < 0 || n < 0) return 0;",
            "\t\treturn f[n] * g[n - m] % mod;",
            "\t}",
            "",
            "\tint catalan(int n) {",
            "\t\treturn (combi(2 * n, n) - combi(2 * n, n - 1) + mod) % mod;",
            "\t}",
            "",
            "\tint inv(int n) {",
            "\t\treturn f[n - 1] * g[n] % mod;",
            "\t}",
            "};"
        ],
        "description": "pnc implementation"
    },
	"dpheq": {
        "prefix": "dpheq",
        "body": [
            "class DiophantineEquations {",
            "public:",
            "\tDiophantineEquations() {}",
            "",
            "\ttuple<int, int, int> euclidean_gcd(int a, int b) {",
            "\t\tif (b == 0) return make_tuple(a, 1, 0);",
            "\t\ttuple<int, int, int> result = euclidean_gcd(b, a % b);",
            "\t\tint g = get<0>(result);",
            "\t\tint x1 = get<1>(result);",
            "\t\tint y1 = get<2>(result);",
            "\t\tint x = y1;",
            "\t\tint y = x1 - (a / b) * y1;",
            "\t\treturn make_tuple(g, x, y);",
            "\t}",
            "",
            "\tpair<int, int> soln(int a, int b, int c, int t = 1e18, int t1 = 1e18) {",
            "\t\tint g = gcd(a, b);",
            "\t\tif (c % g != 0) return make_pair(-1, -1);",
            "\t\ttuple<int, int, int> result = euclidean_gcd(a, b);",
            "\t\tint x = get<1>(result);",
            "\t\tint y = get<2>(result);",
            "\t\tint k3 = x * (c / g);",
            "\t\tint n1 = y * (c / g);",
            "\t\tint k1 = max((int)ceil(-k3 * g / (double)b), (int)ceil((n1 - t1) / (a / (double)g)));",
            "\t\tint kmaxi = min((int)floor((t - k3) / (b / (double)g)), (int)floor(n1 / (a / (double)g)));",
            "\t\tif (k1 <= kmaxi) {",
            "\t\t\tint k = k1;",
            "\t\t\tint m = k3 + k * (b / g);",
            "\t\t\tint n = n1 - k * (a / g);",
            "\t\t\treturn make_pair(m, n);",
            "\t\t}",
            "\t\treturn make_pair(-1, -1);",
            "\t}",
            "",
            "\tpair<int, int> sollnll(int a, int b, int c, int t, int t1, int m_lower, int n_lower) {",
            "\t\tint g = gcd(a, b);",
            "\t\tif (c % g != 0) return make_pair(-1, -1);",
            "\t\ttuple<int, int, int> result = euclidean_gcd(a, b);",
            "\t\tint x = get<1>(result);",
            "\t\tint y = get<2>(result);",
            "\t\tint k3 = x * (c / g);",
            "\t\tint n1 = y * (c / g);",
            "\t\tint k1 = max((int)ceil((m_lower - k3 * g) / (double)b), (int)ceil((n1 - t1) / (a / (double)g)));",
            "\t\tint kmaxi = min((int)floor((t - k3) / (b / (double)g)), (int)floor((n1 - n_lower) / (a / (double)g)));",
            "\t\tif (k1 <= kmaxi) {",
            "\t\t\tint k = k1;",
            "\t\t\tint m = k3 + k * (b / g);",
            "\t\t\tint n = n1 - k * (a / g);",
            "\t\t\tif (m_lower <= m && m <= t && n_lower <= n && n <= t1) {",
            "\t\t\t\treturn make_pair(m, n);",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn make_pair(-1, -1);",
            "\t}",
            "};"
        ],
        "description": "dpheq implementation"
    },
	"graphs": {
        "prefix": "graphs",
        "body": [
            "vector<int> bellman_ford(int n, vector<tuple<int, int, int>> &edges, int start){",
            "\tvector<int> dist(n, INF), pred(n, -1);",
            "\tdist[start] = 0;",
            "\tfor (int i = 0; i < n - 1; i++) {",
            "\t\tfor (int i = 0; i < edges.size(); i++) {",
            "\t\tint u = get<0>(edges[i]);",
            "\t\tint v = get<1>(edges[i]);",
            "\t\tint d = get<2>(edges[i]);",
            "\t\t\tif (dist[u] != INF && dist[u] + d < dist[v]) {",
            "\t\t\t\tdist[v] = dist[u] + d;",
            "\t\t\t\tpred[v] = u;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn dist;",
            "}",
            "",
            "class BinaryLift {",
            "public:",
            "\tint n, L;",
            "\tvector<int> depth;",
            "\tvector<vector<int>> parent;",
            "",
            "\tBinaryLift(vector<vector<int>>& graph, int root = 0) {",
            "\t\tn = graph.size();",
            "\t\tL = 32 - __builtin_clz(n);",
            "\t\tparent.assign(L, vector<int>(n, -1));",
            "\t\tdepth.assign(n, -1);",
            "\t\tqueue<int> bfs;",
            "\t\tbfs.push(root);",
            "\t\tdepth[root] = 0;",
            "\t\twhile (!bfs.empty()) {",
            "\t\t\tint node = bfs.front(); bfs.pop();",
            "\t\t\tfor (int nei : graph[node]) {",
            "\t\t\t\tif (depth[nei] == -1) {",
            "\t\t\t\t\tparent[0][nei] = node;",
            "\t\t\t\t\tdepth[nei] = depth[node] + 1;",
            "\t\t\t\t\tbfs.push(nei);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (int i = 1; i < L; i++) {",
            "\t\t\tfor (int v = 0; v < n; v++) {",
            "\t\t\t\tif (parent[i - 1][v] != -1)",
            "\t\t\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tint lca(int a, int b) {",
            "\t\tif (depth[a] < depth[b]) swap(a, b);",
            "\t\tint d = depth[a] - depth[b];",
            "\t\tfor (int i = 0; i < L; i++) {",
            "\t\t\tif (d & (1LL << i)) a = parent[i][a];",
            "\t\t}",
            "\t\tif (a == b) return a;",
            "\t\tfor (int i = L - 1; i >= 0; i--) {",
            "\t\t\tif (parent[i][a] != parent[i][b]) {",
            "\t\t\t\ta = parent[i][a];",
            "\t\t\t\tb = parent[i][b];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn parent[0][a];",
            "\t}",
            "",
            "\tint distance(int a, int b) {",
            "\t\treturn depth[a] + depth[b] - 2 * depth[lca(a, b)];",
            "\t}",
            "",
            "\tint kth_ancestor(int a, int k) {",
            "\t\tif (depth[a] < k) return -1;",
            "\t\tfor (int i = 0; i < L; i++) {",
            "\t\t\tif (k & (1LL << i)) a = parent[i][a];",
            "\t\t}",
            "\t\treturn a;",
            "\t}",
            "};",
            "",
            "vector<int> kahn(vector<vector<int>>& graph) {",
            "\tint n = graph.size();",
            "\tvector<int> indeg(n, 0), res;",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tfor (int e : graph[i])",
            "\t\t\tindeg[e]++;",
            "\tqueue<int> q;",
            "\tfor (int i = 0; i < n; i++)",
            "\t\tif (indeg[i] == 0) q.push(i);",
            "\twhile (!q.empty()) {",
            "\t\tint node = q.front(); q.pop();",
            "\t\tres.push_back(node);",
            "\t\tfor (int e : graph[node]) {",
            "\t\t\tindeg[e]--;",
            "\t\t\tif (indeg[e] == 0) q.push(e);",
            "\t\t}",
            "\t}",
            "\treturn res.size() == n ? res : vector<int>();",
            "}",
            "",
            "vector<pair<int, int>> dfs(vector<vector<int>>& graph) {",
            "\tint n = graph.size(), time = 0;",
            "\tvector<pair<int, int>> starttime(n, {0, 0});",
            "\tstack<tuple<int, int, int>> stack;",
            "\tstack.emplace(0, -1, 0);",
            "\twhile (!stack.empty()) {",
            "\t\tint cur, prev, state;",
            "\t\tcur = get<0>(stack.top());",
            "\t\tprev = get<1>(stack.top());",
            "\t\tstate = get<2>(stack.top());",
            "\t\tstack.pop();",
            "\t\tif (state == 0) {",
            "\t\t\tstarttime[cur].first = time++;",
            "\t\t\tstack.emplace(cur, prev, 1);",
            "\t\t\tfor (int neighbor : graph[cur]) {",
            "\t\t\t\tif (neighbor == prev) continue;",
            "\t\t\t\tstack.emplace(neighbor, cur, 0);",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tstarttime[cur].second = time;",
            "\t\t}",
            "\t}",
            "\treturn starttime;",
            "}",
            "",
            "vector<int> euler_path(unordered_map<int, multiset<int>>& d) {",
            "\tvector<int> ans;",
            "\tstack<int> start;",
            "\tstart.push(1);",
            "\twhile (!start.empty()) {",
            "\t\tint cur = start.top();",
            "\t\tif (d[cur].empty()) {",
            "\t\t\tans.push_back(cur);",
            "\t\t\tstart.pop();",
            "\t\t} else {",
            "\t\t\tint k1 = *d[cur].begin();",
            "\t\t\td[cur].erase(d[cur].begin());",
            "\t\t\td[k1].erase(d[k1].find(cur));",
            "\t\t\tstart.push(k1);",
            "\t\t}",
            "\t}",
            "\treturn ans;",
            "}",
            "",
            "class TwoSat {",
            "public:",
            "\tint n;",
            "\tvector<vector<int>> graph;",
            "",
            "\tTwoSat(int n) : n(n), graph(2 * n) {}",
            "",
            "\tint negate(int x) {",
            "\t\treturn x < n ? x + n : x - n;",
            "\t}",
            "",
            "\tvoid _imply(int x, int y) {",
            "\t\tgraph[x].push_back(y);",
            "\t\tgraph[negate(y)].push_back(negate(x));",
            "\t}",
            "",
            "\tvoid either(int x, int y) {",
            "\t\t_imply(negate(x), y);",
            "\t\t_imply(negate(y), x);",
            "\t}",
            "",
            "\tvoid set(int x) {",
            "\t\t_imply(negate(x), x);",
            "\t}",
            "",
            "\tvector<vector<int>> find_SCC() {",
            "\t\tint n = graph.size();",
            "\t\tvector<int> order, comp(n, -1), low(n), depth(n, -1);",
            "\t\tvector<vector<int>> SCC;",
            "\t\tstack<int> st;",
            "\t\tint timer = 0;",
            "",
            "\t\tfunction<void(int)> dfs = [&](int v) {",
            "\t\t\tlow[v] = depth[v] = timer++;",
            "\t\t\tst.push(v);",
            "\t\t\tfor (int u : graph[v]) {",
            "\t\t\t\tif (depth[u] == -1) dfs(u);",
            "\t\t\t\tif (comp[u] == -1) low[v] = min(low[v], low[u]);",
            "\t\t\t}",
            "\t\t\tif (low[v] == depth[v]) {",
            "\t\t\t\tSCC.emplace_back();",
            "\t\t\t\twhile (true) {",
            "\t\t\t\t\tint u = st.top(); st.pop();",
            "\t\t\t\t\tcomp[u] = SCC.size() - 1;",
            "\t\t\t\t\tSCC.back().push_back(u);",
            "\t\t\t\t\tif (u == v) break;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t};",
            "",
            "\t\tfor (int i = 0; i < n; i++) {",
            "\t\t\tif (depth[i] == -1) dfs(i);",
            "\t\t}",
            "\t\treturn SCC;",
            "\t}",
            "",
            "\tpair<bool, vector<int>> solve() {",
            "\t\tauto SCC = find_SCC();",
            "\t\tvector<int> order(2 * n, 0);",
            "\t\tfor (int i = 0; i < SCC.size(); i++)",
            "\t\t\tfor (int x : SCC[i])",
            "\t\t\t\torder[x] = i;",
            "\t\tvector<int> res(n);",
            "\t\tfor (int i = 0; i < n; i++) {",
            "\t\t\tif (order[i] == order[negate(i)])",
            "\t\t\t\treturn {false, {}};",
            "\t\t\tres[i] = order[i] > order[negate(i)];",
            "\t\t}",
            "\t\treturn {true, res};",
            "\t}",
            "};"
        ],
        "description": "graphs implementation"
    },
	"bgraphs": {
        "prefix": "bgraphs",
        "body": [
            "vector<int> bfsf(vector<vector<int>>& graph, int start = 0) {",
            "\tvector<int> bfs;",
            "\tvector<bool> visited(graph.size(), false);",
            "\tqueue<int> q;",
            "\tq.push(start);",
            "\tvisited[start] = true;",
            "\twhile (!q.empty()) {",
            "\t\tint u = q.front(); q.pop();",
            "\t\tbfs.push_back(u);",
            "\t\tfor (int j : graph[u]) {",
            "\t\t\tif (!visited[j]) {",
            "\t\t\t\tvisited[j] = true;",
            "\t\t\t\tq.push(j);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn bfs;",
            "}",
            "",
            "pair<vector<int>, vector<int>> dijkstra(vector<vector<pair<int, int>>>& graph, int start, int n) {",
            "\tvector<int> dist(n, INF), parents(n, -1);",
            "\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
            "\tdist[start] = 0;",
            "\tpq.emplace(0, start);",
            "\twhile (!pq.empty()) {",
            "\t\tint path_len = pq.top().first; int v = pq.top().second; pq.pop();",
            "\t\tif (path_len > dist[v]) continue;",
            "\t\tfor (const auto& p : graph[v]) {",
            "\t\t\tint w = p.first, edge_len = p.second;",
            "\t\t\tif (edge_len + path_len < dist[w]) {",
            "\t\t\t\tdist[w] = edge_len + path_len;",
            "\t\t\t\tparents[w] = v;",
            "\t\t\t\tpq.emplace(dist[w], w);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn {dist, parents};",
            "}",
            "",
            "",
            "vector<bool> dfs(vector<vector<int>>& graph, int start = 0) {",
            "\tint n = graph.size();",
            "\tvector<bool> visited(n, false);",
            "\tstack<int> st;",
            "\tst.push(start);",
            "\twhile (!st.empty()) {",
            "\t\tint node = st.top();",
            "\t\tif (!visited[node]) {",
            "\t\t\tvisited[node] = true;",
            "\t\t\tfor (int child : graph[node]) {",
            "\t\t\t\tif (!visited[child]) {",
            "\t\t\t\t\tst.push(child);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t} else {",
            "\t\t\tst.pop();",
            "\t\t}",
            "\t}",
            "\treturn visited;",
            "}"
        ],
        "description": "bgraphs implementation"
    },
	"DSU": {
        "prefix": "dsu",
        "body": [
            "class DisjointSetUnion {",
            "public:",
            "\tvector<int> parent, size;",
            "",
            "\tDisjointSetUnion(int n) : parent(n), size(n, 1) {",
            "\t\tiota(parent.begin(), parent.end(), 0);",
            "\t}",
            "",
            "\tint find(int a) {",
            "\t\tif (parent[a] != a) {",
            "\t\t\tparent[a] = find(parent[a]);",
            "\t\t}",
            "\t\treturn parent[a];",
            "\t}",
            "",
            "\tvoid unite(int a, int b) {",
            "\t\ta = find(a);",
            "\t\tb = find(b);",
            "\t\tif (a != b) {",
            "\t\t\tif (size[a] < size[b]) swap(a, b);",
            "\t\t\tparent[b] = a;",
            "\t\t\tsize[a] += size[b];",
            "\t\t}",
            "\t}",
            "",
            "\tint set_size(int a) {",
            "\t\treturn size[find(a)];",
            "\t}",
            "",
            "\tint notfind(int a) {",
            "\t\tint k = find(a);",
            "\t\tfor (int i = 0; i < parent.size(); i++) {",
            "\t\t\tif (find(i) != k) {",
            "\t\t\t\treturn i;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn -1;",
            "\t}",
            "};"
        ],
        "description": "DSU implementation"
    },
	"fft": {
        "prefix": "fft",
        "body": [
            "class FFT {",
            "public:",
            "\tstatic const int MOD = 998244353;",
            "\tstatic const int MOD1 = 469762049;",
            "\tint MOD2, mod_inv;",
            "\tvector<int> W, W1, iW, iW1;",
            "",
            "\tFFT() {",
            "\t\tMOD2 = power(MOD, MOD1 - 2, MOD1);",
            "\t\tmod_inv = XT_GCD(MOD, MOD1).second % MOD1;",
            "\t\tint g = 3;",
            "\t\tint ig = power(g, MOD - 2, MOD);",
            "\t\tint ig1 = power(g, MOD1 - 2, MOD1);",
            "\t\tW.resize(30); W1.resize(30); iW.resize(30); iW1.resize(30);",
            "\t\tfor (int i = 0; i < 30; ++i) {",
            "\t\t\tW[i] = power(g, (MOD - 1) >> i, MOD);",
            "\t\t\tW1[i] = power(g, (MOD1 - 1) >> i, MOD1);",
            "\t\t\tiW[i] = power(ig, (MOD - 1) >> i, MOD);",
            "\t\t\tiW1[i] = power(ig1, (MOD1 - 1) >> i, MOD1);",
            "\t\t}",
            "\t}",
            "",
            "\tint power(int base, int exp, int mod) {",
            "\t\tint res = 1;",
            "\t\twhile (exp) {",
            "\t\t\tif (exp % 2) res = res * base % mod;",
            "\t\t\tbase = base * base % mod;",
            "\t\t\texp /= 2;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "\tpair<int, int> XT_GCD(int a, int b) {",
            "\t\tif (b == 0) return {a, 1};",
            "\t\tpair<int,int> k9 = XT_GCD(b, a % b);",
	        "\t\tint g = k9.first;int x1 = k9.second;",
            "\t\treturn {g, x1 - (a / b) * x1};",
            "\t}",
            "",
            "\tint CRT(int a, int mod1, int b, int mod2) {",
            "\t\treturn (a + (b - a) * mod_inv % mod2 * mod1) % (mod1 * mod2);",
            "\t}",
            "",
            "\tvoid fft(int k, vector<int>& f, vector<int>& f1) {",
            "\t\tfor (int l = k; l > 0; --l) {",
            "\t\t\tint d = 1 << (l - 1);",
            "\t\t\tvector<pair<int, int>> U = {{1, 1}};",
            "\t\t\tfor (int i = 0; i < d; ++i)",
            "\t\t\t\tU.emplace_back(U.back().first * W[l] % MOD, U.back().second * W1[l] % MOD1);",
            "\t\t\tfor (int i = 0; i < (1 << (k - l)); ++i) {",
            "\t\t\t\tfor (int j = 0; j < d; ++j) {",
            "\t\t\t\t\tint s = i * 2 * d + j;",
            "\t\t\t\t\tint tmp_f = f[s] - f[s + d];",
            "\t\t\t\t\tint tmp_f1 = f1[s] - f1[s + d];",
            "\t\t\t\t\tf[s] = (f[s] + f[s + d]) % MOD;",
            "\t\t\t\t\tf[s + d] = U[j].first * tmp_f % MOD;",
            "\t\t\t\t\tf1[s] = (f1[s] + f1[s + d]) % MOD1;",
            "\t\t\t\t\tf1[s + d] = U[j].second * tmp_f1 % MOD1;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid ifft(int k, vector<int>& f, vector<int>& f1) {",
            "\t\tfor (int l = 1; l <= k; ++l) {",
            "\t\t\tint d = 1 << (l - 1);",
            "\t\t\tfor (int i = 0; i < (1 << (k - l)); ++i) {",
            "\t\t\t\tint u = 1, u1 = 1;",
            "\t\t\t\tfor (int j = i * 2 * d; j < (i * 2 + 1) * d; ++j) {",
            "\t\t\t\t\tf[j + d] = f[j + d] * u % MOD;",
            "\t\t\t\t\tf[j] = (f[j] + f[j + d]) % MOD;",
            "\t\t\t\t\tf[j + d] = (f[j] - f[j + d] + MOD) % MOD;",
            "\t\t\t\t\tu = u * iW[l] % MOD;",
            "\t\t\t\t\tf1[j + d] = f1[j + d] * u1 % MOD1;",
            "\t\t\t\t\tf1[j] = (f1[j] + f1[j + d]) % MOD1;",
            "\t\t\t\t\tf1[j + d] = (f1[j] - f1[j + d] + MOD1) % MOD1;",
            "\t\t\t\t\tu1 = u1 * iW1[l] % MOD1;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvector<int> convolve(vector<int> A, vector<int> B) {",
            "\t\tint n0 = A.size() + B.size() - 1;",
            "\t\tint k = 0;",
            "\t\twhile ((1 << k) < n0) ++k;",
            "\t\tint n = 1 << k;",
            "\t\tA.resize(n, 0);",
            "\t\tB.resize(n, 0);",
            "\t\tvector<int> A1 = A, B1 = B;",
            "\t\tfft(k, A, A1);",
            "\t\tfft(k, B, B1);",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\tA[i] = A[i] * B[i] % MOD;",
            "\t\t\tA1[i] = A1[i] * B1[i] % MOD1;",
            "\t\t}",
            "\t\tifft(k, A, A1);",
            "\t\tint inv = power(n, MOD - 2, MOD);",
            "\t\tint inv1 = power(n, MOD1 - 2, MOD1);",
            "\t\tA.resize(n0);",
            "\t\tfor (int i = 0; i < n0; ++i) {",
            "\t\t\tA[i] = CRT(A[i] * inv % MOD, MOD, A1[i] * inv1 % MOD1, MOD1);",
            "\t\t}",
            "\t\treturn A;",
            "\t}",
            "};"
        ],
        "description": "fft implementation"
    },
    "sorttree": {
        "prefix": "sorttree",
        "body": [
            "class MergeSortTree {",
            "\tpublic:",
            "\t\tint n;",
            "\t\tvector<vector<int>> tree;",
            "\t\tstatic vector<int> merge(const vector<int>& a, const vector<int>& b) {",
            "\t\t\tint i = 0, j = 0, k =0;",
            "\t\t\tint t = a.size();",
            "\t\t\tint t1 = b.size();",
            "\t\t\tvector<int> L(t+t1);",
            "\t\t\twhile (i < t && j < t1) {",
            "\t\t\t\tif (a[i] < b[j]) {",
            "\t\t\t\t\tL[k++] = (a[i++]);",
            "\t\t\t\t} else {",
            "\t\t\t\t\tL[k++] = (b[j++]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\twhile (i < t) L[k++] = (a[i++]);",
            "\t\t\twhile (j < t1) L[k++] = (b[j++]);",
            "\t\t\treturn L;",
            "\t\t}",
            "\t\tstatic int func(const vector<int>& L, int l, int r) {",
            "\t\t\treturn upper_bound(L.begin(), L.end(), r) - lower_bound(L.begin(), L.end(), l);",
            "\t\t}",
            "\t\tMergeSortTree(const vector<int>& data) {",
            "\t\t\tn = data.size();",
            "\t\t\ttree.resize(2 * n);",
            "\t\t\tbuild(data);",
            "\t\t}",
            "\t\tvoid build(const vector<int>& data) {",
            "\t\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\t\ttree[n + i] = {data[i]};",
            "\t\t\t}",
            "\t\t\tfor (int i = n - 1; i > 0; --i) {",
            "\t\t\t\ttree[i] = merge(tree[i * 2], tree[i * 2 + 1]);",
            "\t\t\t}",
            "\t\t}",
            "\t\tvoid update(int pos, int value) {",
            "\t\t\tpos += n;",
            "\t\t\ttree[pos] = {value};",
            "\t\t\twhile (pos > 1) {",
            "\t\t\t\tpos /= 2;",
            "\t\t\t\ttree[pos] = merge(tree[pos * 2], tree[pos * 2 + 1]);",
            "\t\t\t}",
            "\t\t}",
            "\t\tint query(int left, int right, int l, int r) {",
            "\t\t\tleft += n;",
            "\t\t\tright += n;",
            "\t\t\tint res = 0;",
            "\t\t\twhile (left < right) {",
            "\t\t\t\tif (left % 2 == 1) {",
            "\t\t\t\t\tres += func(tree[left], l, r);",
            "\t\t\t\t\tleft++;",
            "\t\t\t\t}",
            "\t\t\t\tif (right % 2 == 1) {",
            "\t\t\t\t\tright--;",
            "\t\t\t\t\tres += func(tree[right], l, r);",
            "\t\t\t\t}",
            "\t\t\t\tleft >>= 1;",
            "\t\t\t\tright >>= 1;",
            "\t\t\t}",
            "\t\t\treturn res;",
            "\t\t}",
            "\t};"
        ],
        "description": "sorttree implementation"
    }
}