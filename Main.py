{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
    "cp": {
        "prefix": "cp",
        "body": [
            "import sys,math,cmath,random,os",
            "from heapq import heappush,heappop",
            "from bisect import bisect_right,bisect_left",
            "from collections import Counter,deque,defaultdict",
            "from itertools import permutations,combinations",
            "from io import BytesIO, IOBase",
            "from decimal import Decimal,getcontext",
            "",
            "BUFSIZE = 8192",
            "class FastIO(IOBase):",
            "\tnewlines = 0",
            "\tdef __init__(self, file):",
            "\t\tself._file = file",
            "\t\tself._fd = file.fileno()",
            "\t\tself.buffer = BytesIO()",
            "\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "\t\tself.write = self.buffer.write if self.writable else None",
            "\tdef read(self):",
            "\t\twhile True:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tif not b:",
            "\t\t\t\tbreak",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines = 0",
            "\t\treturn self.buffer.read()",
            "\tdef readline(self):",
            "\t\twhile self.newlines == 0:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tself.newlines = b.count(b\"\\n\") + (not b)",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines -= 1",
            "\t\treturn self.buffer.readline()",
            "\tdef flush(self):",
            "\t\tif self.writable:",
            "\t\t\tos.write(self._fd, self.buffer.getvalue())",
            "\t\t\tself.buffer.truncate(0), self.buffer.seek(0)",
            "class IOWrapper(IOBase):",
            "\tdef __init__(self, file):",
            "\t\tself.buffer = FastIO(file)",
            "\t\tself.flush = self.buffer.flush",
            "\t\tself.writable = self.buffer.writable",
            "\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")",
            "\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "",
            "# functions #",
            "# MOD = 998244353",
            "MOD = 10**9 + 7",
            "RANDOM = random.randrange(1,2**62)",
            "def gcd(a,b):",
            "\twhile b:",
            "\t\ta,b = b,a%b",
            "\treturn a",
            "def lcm(a,b):",
            "\treturn a//gcd(a,b)*b",
            "def w(x):",
            "\treturn x ^ RANDOM",
            "II = lambda : int(sys.stdin.readline().strip())",
            "LII = lambda : list(map(int, sys.stdin.readline().split()))",
            "MI = lambda x : x(map(int, sys.stdin.readline().split()))",
            "SI = lambda : sys.stdin.readline().strip()",
            "SLI = lambda : list(map(lambda x:ord(x)-97,sys.stdin.readline().strip()))",
            "LII_1 = lambda : list(map(lambda x:int(x)-1, sys.stdin.readline().split()))",
            "LII_C = lambda x : list(map(x, sys.stdin.readline().split()))",
            "MATI = lambda x : [list(map(int, sys.stdin.readline().split())) for _ in range(x)]",
            "##",
            "",
            "#String hashing: shclass, fenwick sortedlist: fsortl, Number: numtheory/numrare, SparseTable: SparseTable",
            "#Bucket Sorted list: bsortl, Segment Tree(lp,selfop): SegmentTree, bootstrap: bootstrap, Trie: tries",
            "#binary indexed tree: BIT, Segment Tree(point updates): SegmentPoint, Convex Hull: hull, BitArray: bitarray",
            "#Combinatorics: pnc, Diophantine Equations: dpheq, DSU: DSU, Geometry: Geometry, FFT: fft, XOR_dict: xdict",
            "#Persistent Segment Tree: perseg, Binary Trie: b_trie, HLD: hld, String funcs: sf, Segment Tree(lp): SegmentOther",
            "#Graph1(dnc,bl): graphadv, Graph2(khn,sat): 2sat, Graph3(fltn,bprt): graphflatten, Graph4(ep,tp,fw,bmf): graphoth",
            "#Graph5(djik,bfs,dfs): graph, Graph6(dfsin): dfsin, utils: utils, Persistent DSU: perdsu, Merge Sort Tree: sorttree",
            "#2-D BIT: 2DBIT",
            "#Template : https://github.com/thepratholic/CP-Template-Py-Cpp",
            "# input_file = open(r'input.txt', 'r');sys.stdin = input_file",
            "",
            "def solve():",
            "\tn = II()",
            "\tL = LII()",
            "\t#L1 = LII()",
            "\t#st = SI()",
            "for _ in range(II()):",
            "\tsolve()"
        ],
        "description": "cp implementation"
    },
    "tcp": {
		"prefix": "tcp",
		"body": [
			"import sys,math,cmath,random,os",
            "from heapq import heappush,heappop",
            "from bisect import bisect_right,bisect_left",
            "from collections import Counter,deque,defaultdict",
            "from itertools import permutations,combinations",
            "from io import BytesIO, IOBase",
            "from decimal import Decimal,getcontext",
            "",
            "BUFSIZE = 8192",
            "class FastIO(IOBase):",
            "\tnewlines = 0",
            "\tdef __init__(self, file):",
            "\t\tself._file = file",
            "\t\tself._fd = file.fileno()",
            "\t\tself.buffer = BytesIO()",
            "\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode",
            "\t\tself.write = self.buffer.write if self.writable else None",
            "\tdef read(self):",
            "\t\twhile True:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tif not b:",
            "\t\t\t\tbreak",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines = 0",
            "\t\treturn self.buffer.read()",
            "\tdef readline(self):",
            "\t\twhile self.newlines == 0:",
            "\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
            "\t\t\tself.newlines = b.count(b\"\\n\") + (not b)",
            "\t\t\tptr = self.buffer.tell()",
            "\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)",
            "\t\tself.newlines -= 1",
            "\t\treturn self.buffer.readline()",
            "\tdef flush(self):",
            "\t\tif self.writable:",
            "\t\t\tos.write(self._fd, self.buffer.getvalue())",
            "\t\t\tself.buffer.truncate(0), self.buffer.seek(0)",
            "class IOWrapper(IOBase):",
            "\tdef __init__(self, file):",
            "\t\tself.buffer = FastIO(file)",
            "\t\tself.flush = self.buffer.flush",
            "\t\tself.writable = self.buffer.writable",
            "\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))",
            "\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")",
            "\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")",
            "sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
            "",
            "# functions #",
            "# MOD = 998244353",
            "MOD = 10**9 + 7",
            "RANDOM = random.randrange(1,2**62)",
            "def gcd(a,b):",
            "\twhile b:",
            "\t\ta,b = b,a%b",
            "\treturn a",
            "def lcm(a,b):",
            "\treturn a//gcd(a,b)*b",
            "def w(x):",
            "\treturn x ^ RANDOM",
            "II = lambda : int(sys.stdin.readline().strip())",
            "LII = lambda : list(map(int, sys.stdin.readline().split()))",
            "MI = lambda x : x(map(int, sys.stdin.readline().split()))",
            "SI = lambda : sys.stdin.readline().strip()",
            "SLI = lambda : list(map(lambda x:ord(x)-97,sys.stdin.readline().strip()))",
            "LII_1 = lambda : list(map(lambda x:int(x)-1, sys.stdin.readline().split()))",
            "LII_C = lambda x : list(map(x, sys.stdin.readline().split()))",
            "MATI = lambda x : [list(map(int, sys.stdin.readline().split())) for _ in range(x)]",
            "##",
            "",
            "#String hashing: shclass, fenwick sortedlist: fsortl, Number: numtheory/numrare, SparseTable: SparseTable",
            "#Bucket Sorted list: bsortl, Segment Tree(lp,selfop): SegmentTree, bootstrap: bootstrap, Trie: tries",
            "#binary indexed tree: BIT, Segment Tree(point updates): SegmentPoint, Convex Hull: hull, BitArray: bitarray",
            "#Combinatorics: pnc, Diophantine Equations: dpheq, DSU: DSU, Geometry: Geometry, FFT: fft, XOR_dict: xdict",
            "#Persistent Segment Tree: perseg, Binary Trie: b_trie, HLD: hld, String funcs: sf, Segment Tree(lp): SegmentOther",
            "#Graph1(dnc,bl): graphadv, Graph2(khn,sat): 2sat, Graph3(fltn,bprt): graphflatten, Graph4(ep,tp,fw,bmf): graphoth",
            "#Graph5(djik,bfs,dfs): graph, Graph6(dfsin): dfsin, utils: utils, Persistent DSU: perdsu, Merge Sort Tree: sorttree",
            "#2-D BIT: 2DBIT",
            "#Template : https://github.com/OmAmar106/Template-for-Competetive-Programming",
            "# input_file = open(r'input.txt', 'r');sys.stdin = input_file",
            "",
            "def solve():",
            "\tn = II()",
            "\tL = LII()",
            "\t#L1 = LII()",
            "\t#st = SI()",
            "solve()"
	    ],  
		"description": "atcoder/cses template"
	},
    "hull": {
		"prefix": "hull",
		"body": [
            "INF = float('inf')",
            "class Line:",
            "\tdef __init__(self, m, b):",
            "\t\tself.m = m",
            "\t\tself.b = b",
            "\tdef __call__(self, x):",
            "\t\treturn self.m * x + self.b",
            "class ConvexHull:",
            "\tdef __init__(self, n=1000000):",
            "\t\t# put n equal to max value of ai , bi , you may need to do coordinate compression in case it is upto 10**9",
            "\t\t# works for value which are not increasing as well",
            "\t\tself.n = n",
            "\t\tself.seg = [Line(0, INF)] * (4 * n)",
            "\t\tself.lo = [0] * (4 * n)",
            "\t\tself.hi = [0] * (4 * n)",
            "\t\tself.build(1,1,n)",
            "\tdef build(self, i, l, r):",
            "\t\tstack = [(i, l, r)]",
            "\t\twhile stack:",
            "\t\t\tidx, left, right = stack.pop()",
            "\t\t\tself.lo[idx] = left",
            "\t\t\tself.hi[idx] = right",
            "\t\t\tself.seg[idx] = Line(0, INF)",
            "\t\t\tif left == right:",
            "\t\t\t\tcontinue",
            "\t\t\tmid = (left + right) // 2",
            "\t\t\tstack.append((2 * idx + 1, mid + 1, right))",
            "\t\t\tstack.append((2 * idx, left, mid))",
            "\tdef insert(self,L):",
            "\t\tpos = 1",
            "\t\twhile True:",
            "\t\t\tl, r = self.lo[pos], self.hi[pos]",
            "\t\t\tif l == r:",
            "\t\t\t\tif L(l) < self.seg[pos](l):",
            "\t\t\t\t\tself.seg[pos] = L",
            "\t\t\t\tbreak",
            "\t\t\tm = (l + r) // 2",
            "\t\t\tif self.seg[pos].m < L.m:",
            "\t\t\t\tself.seg[pos], L = L, self.seg[pos]",
            "\t\t\tif self.seg[pos](m) > L(m):",
            "\t\t\t\tself.seg[pos], L = L, self.seg[pos]",
            "\t\t\t\tpos = 2*pos",
            "\t\t\telse:",
            "\t\t\t\tpos = 2*pos+1",
            "\tdef query(self,x):",
            "\t\ti = 1",
            "\t\tres = self.seg[i](x)",
            "\t\tpos = i",
            "\t\twhile True:",
            "\t\t\tl, r = self.lo[pos], self.hi[pos]",
            "\t\t\tif l == r:",
            "\t\t\t\treturn min(res, self.seg[pos](x))",
            "\t\t\tm = (l + r) // 2",
            "\t\t\tif x < m:",
            "\t\t\t\tres = min(res, self.seg[pos](x))",
            "\t\t\t\tpos = 2 * pos",
            "\t\t\telse:",
            "\t\t\t\tres = min(res, self.seg[pos](x))",
            "\t\t\t\tpos = (2 * pos + 1)",
            "",
            "class CHT:",
            "\t# Works only for increasing value of input",
            "\tdef __init__(self, tp):",
            "\t\tself.t = tp",
            "\t\tself.ptr = 0",
            "\t\tself.v = []",
            "\tdef bad(self, l1, l2, l3):",
            "\t\ta = (l3.c - l1.c) * (l1.m - l2.m)",
            "\t\tb = (l2.c - l1.c) * (l1.m - l3.m)",
            "\t\tif self.t in [1, 4]:",
            "\t\t\treturn a <= b",
            "\t\treturn a >= b",
            "\tdef add(self, line):",
            "\t\tself.v.append(line)",
            "\t\twhile len(self.v) >= 3 and self.bad(self.v[-3], self.v[-2], self.v[-1]):",
            "\t\t\tself.v.pop(-2)",
            "\tdef val(self, ind, x):",
            "\t\treturn self.v[ind].m * x + self.v[ind].c",
            "\tdef query(self, x):",
            "\t\tl, r = 0, len(self.v) - 1",
            "\t\tans = 0",
            "\t\twhile l <= r:",
            "\t\t\tmid1 = l + (r - l) // 3",
            "\t\t\tmid2 = r - (r - l) // 3",
            "\t\t\tif self.t & 1:",
            "\t\t\t\tif self.val(mid1, x) <= self.val(mid2, x):",
            "\t\t\t\t\tr = mid2 - 1",
            "\t\t\t\t\tans = self.val(mid1, x)",
            "\t\t\t\telse:",
            "\t\t\t\t\tl = mid1 + 1",
            "\t\t\t\t\tans = self.val(mid2, x)",
            "\t\t\telse:",
            "\t\t\t\tif self.val(mid1, x) >= self.val(mid2, x):",
            "\t\t\t\t\tr = mid2 - 1",
            "\t\t\t\t\tans = self.val(mid1, x)",
            "\t\t\t\telse:",
            "\t\t\t\t\tl = mid1 + 1",
            "\t\t\t\t\tans = self.val(mid2, x)",
            "\t\treturn ans",
            "",
            "\tdef query2(self, x):",
            "\t\tif not self.v:",
            "\t\t\treturn 0",
            "\t\tif self.ptr >= len(self.v):",
            "\t\t\tself.ptr = len(self.v) - 1",
            "\t\twhile self.ptr < len(self.v) - 1:",
            "\t\t\tif self.t & 1:",
            "\t\t\t\tif self.val(self.ptr, x) > self.val(self.ptr + 1, x):",
            "\t\t\t\t\tself.ptr += 1",
            "\t\t\t\telse:",
            "\t\t\t\t\tbreak",
            "\t\t\telse:",
            "\t\t\t\tif self.val(self.ptr, x) < self.val(self.ptr + 1, x):",
            "\t\t\t\t\tself.ptr += 1",
            "\t\t\t\telse:",
            "\t\t\t\t\tbreak",
            "\t\treturn self.val(self.ptr, x)"
		],
		"description": "Convex hull trick for minimum queries"
	},
    "pnc": {
        "prefix": "pnc",
        "body": [
            "class Factorial:",
            "\tdef __init__(self, N, mod):",
            "\t\tN += 1",
            "\t\tself.mod = mod",
            "\t\tself.f = [1 for _ in range(N)]",
            "\t\tself.g = [1 for _ in range(N)]",
            "\t\tfor i in range(1, N):",
            "\t\t\tself.f[i] = self.f[i - 1] * i % self.mod",
            "\t\tself.g[-1] = pow(self.f[-1], mod - 2, mod)",
            "\t\tfor i in range(N - 2, -1, -1):",
            "\t\t\tself.g[i] = self.g[i + 1] * (i + 1) % self.mod",
            "\tdef fac(self, n):",
            "\t\treturn self.f[n]",
            "\tdef fac_inv(self, n):",
            "\t\treturn self.g[n]",
            "\tdef combi(self, n, m):",
            "\t\tif m == 0: return 1",
            "\t\tif n < m or m < 0 or n < 0: return 0",
            "\t\treturn self.f[n] * self.g[m] % self.mod * self.g[n - m] % self.mod",
            "\tdef permu(self, n, m):",
            "\t\tif n < m or m < 0 or n < 0: return 0",
            "\t\treturn self.f[n] * self.g[n - m] % self.mod",
            "\tdef catalan(self, n):",
            "\t\treturn (self.combi(2 * n, n) - self.combi(2 * n, n - 1)) % self.mod",
            "\tdef inv(self, n):",
            "\t\treturn self.f[n-1] * self.g[n] % self.mod"
        ],
        "description": "Class for efficient computation of factorials, combinations, permutations, Catalan numbers, and modular inverses with precomputation."
    },
    "numtheory": {
        "prefix": "numtheory",
        "body": [
            "def miller_is_prime(n):",
            "\t\"\"\"",
            "\t\tMiller-Rabin test - O(7 * log2n)",
            "\t\tHas 100% success rate for numbers less than 3e+9",
            "\t\tuse it in case of TC problem",
            "\t\"\"\"",
            "\tif n < 5 or n & 1 == 0 or n % 3 == 0:",
            "\t\treturn 2 <= n <= 3",
            "\ts = ((n - 1) & (1 - n)).bit_length() - 1",
            "\td = n >> s",
            "\tfor a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:",
            "\t\tp = pow(a, d, n)",
            "\t\tif p == 1 or p == n - 1 or a % n == 0:",
            "\t\t\tcontinue",
            "\t\tfor _ in range(s):",
            "\t\t\tp = (p * p) % n",
            "\t\t\tif p == n - 1:",
            "\t\t\t\tbreak",
            "\t\telse:",
            "\t\t\treturn False",
            "\treturn True",
            "",
            "def is_prime(n):",
            "\tif n <= 1:",
            "\t\treturn False",
            "\tif n <= 3:",
            "\t\treturn True",
            "\tif n % 2 == 0 or n % 3 == 0:",
            "\t\treturn False",
            "\ti = 5",
            "\twhile i * i <= n:",
            "\t\tif n % i == 0 or n % (i + 2) == 0:",
            "\t\t\treturn False",
            "\t\ti += 6",
            "\treturn True",
            "",
            "def sieve(n):",
            "\tprimes = []",
            "\tisp = [1] * (n+1)",
            "\tisp[0] = isp[1] = 0",
            "\tfor i in range(2,n+1):",
            "\t\tif isp[i]:",
            "\t\t\tprimes.append(i)",
            "\t\t\tfor j in range(i*i,n+1,i):",
            "\t\t\t\tisp[j] = 0",
            "\treturn primes",
            "",
            "def all_fact(n):",
            "\t\"\"\"",
            "\treturns a sorted list of all distinct factors of n in root n",
            "\t\"\"\"",
            "\tsmall, large = [], []",
            "\tfor i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):",
            "\t\tif not n % i:",
            "\t\t\tsmall.append(i)",
            "\t\t\tlarge.append(n // i)",
            "\tif small[-1] == large[-1]:",
            "\t\tlarge.pop()",
            "\tlarge.reverse()",
            "\tsmall.extend(large)",
            "\treturn small",
            "",
            "calc = False",
            "if calc:",
            "\tdef sieve_unique(N):",
            "\t\tmini = [i for i in range(N)]",
            "\t\tfor i in range(2,N):",
            "\t\t\tif mini[i]==i:",
            "\t\t\t\tfor j in range(2*i,N,i):",
            "\t\t\t\t\tmini[j] = i",
            "\t\treturn mini",
            "",
            "\tMAX_N = 10**6+1",
            "\tLmini = sieve_unique(MAX_N)",
            "",
            "\tdef prime_factors(k,typ=0):",
            "\t\t\"\"\"",
            "\t\t\tWhen the numbers are large this is the best method to get",
            "\t\t\tunique prime factors, precompute n log log n , then each query is log n",
            "\t\t\"\"\"",
            "\t\tif typ==0:",
            "\t\t\tans = Counter()",
            "\t\telif typ==1:",
            "\t\t\tans = set()",
            "\t\telse:",
            "\t\t\tans = []",
            "\t\twhile k!=1:",
            "\t\t\tif typ==0:",
            "\t\t\t\tans[Lmini[k]] += 1",
            "\t\t\telif typ==1:",
            "\t\t\t\tans.add(Lmini[k])",
            "\t\t\telse:",
            "\t\t\t\tans.append(Lmini[k])",
            "\t\t\tk //= Lmini[k]",
            "\t\treturn ans",
            "",
            "\tdef all_factors(x):",
            "\t\t# returns all factors of x in log x + d",
            "\t\tL = list(prime_factors(x).items())",
            "\t\tst = [1]",
            "\t\tfor i in range(len(L)):",
            "\t\t\tfor j in range(len(st)-1,-1,-1):",
            "\t\t\t\tk = L[i][0]",
            "\t\t\t\tfor l in range(L[i][1]):",
            "\t\t\t\t\tst.append(st[j]*k)",
            "\t\t\t\t\tk *= L[i][0]",
            "\t\treturn st"
        ],
        "description": "numtheory implementation"
    },
    "numrare": {
        "prefix": "numrare",
        "body": [
            "def memodict(f):",
            "\tclass memodict(dict):",
            "\t\tdef __missing__(self, key):",
            "\t\t\tret = self[key] = f(key)",
            "\t\t\treturn ret",
            "\treturn memodict().__getitem__",
            "",
            "def pollard_rho(n):",
            "\t# returns a random factor of n",
            "\tif n & 1 == 0:",
            "\t\treturn 2",
            "\tif n % 3 == 0:",
            "\t\treturn 3",
            "\ts = ((n - 1) & (1 - n)).bit_length() - 1",
            "\td = n >> s",
            "\tfor a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:",
            "\t\tp = pow(a, d, n)",
            "\t\tif p == 1 or p == n - 1 or a % n == 0:",
            "\t\t\tcontinue",
            "\t\tfor _ in range(s):",
            "\t\t\tprev = p",
            "\t\t\tp = (p * p) % n",
            "\t\t\tif p == 1:",
            "\t\t\t\treturn gcd(prev - 1, n)",
            "\t\t\tif p == n - 1:",
            "\t\t\t\tbreak",
            "\t\telse:",
            "\t\t\tfor i in range(2, n):",
            "\t\t\t\tx, y = i, (i * i + 1) % n",
            "\t\t\t\tf = gcd(abs(x - y), n)",
            "\t\t\t\twhile f == 1:",
            "\t\t\t\t\tx, y = (x * x + 1) % n, (y * y + 1) % n",
            "\t\t\t\t\ty = (y * y + 1) % n",
            "\t\t\t\t\tf = gcd(abs(x - y), n)",
            "\t\t\t\tif f != n:",
            "\t\t\t\t\treturn f",
            "\treturn n",
            "",
            "@memodict",
            "def prime_factors_large(n):",
            "\t# returns prime factor in n^(1/4) but is probablistic",
            "\tif n <= 1:",
            "\t\treturn Counter()",
            "\tf = pollard_rho(n)",
            "\treturn Counter([n]) if f == n else prime_factors_large(f) + prime_factors_large(n // f)",
            "",
            "def matmul(A,B,MOD=(10**9 + 7)):",
            "\tans = [[0 for i in range(len(B[0]))] for j in range(len(A))]",
            "\tfor i in range(len(A)):",
            "\t\tfor j in range(len(B[0])):",
            "\t\t\tfor k in range(len(B)):",
            "\t\t\t\tans[i][j] = (ans[i][j]+A[i][k]*B[k][j])%MOD",
            "\treturn ans",
            "",
            "def matpow(M,power):",
            "\tsize = len(M)",
            "\tresult = [[1 if i == j else 0 for j in range(size)] for i in range(size)]",
            "\twhile power:",
            "\t\tif power % 2 == 1:",
            "\t\t\tresult = matmul(result, M)",
            "\t\tM = matmul(M, M)",
            "\t\tpower //= 2",
            "\treturn result",
            "",
            "def extended_gcd(a, b):",
            "\t# returns gcd(a, b), s, r s.t. a * s + b * r == gcd(a, b)",
            "\ts, old_s = 0, 1",
            "\tr, old_r = b, a",
            "\twhile r:",
            "\t\tq = old_r // r",
            "\t\told_r, r = r, old_r - q * r",
            "\t\told_s, s = s, old_s - q * s",
            "\treturn old_r, old_s, (old_r - old_s * a) // b if b else 0",
            "",
            "def composite_crt(b, m):",
            "\t# returns x s.t. x = b[i] (mod m[i]) for all i",
            "\tx, m_prod = 0, 1",
            "\tfor bi, mi in zip(b, m):",
            "\t\tg, s, _ = extended_gcd(m_prod, mi)",
            "\t\tif ((bi - x) % mi) % g:",
            "\t\t\treturn None",
            "\t\tx += m_prod * (s * ((bi - x) % mi) // g)",
            "\t\tm_prod = (m_prod * mi) // gcd(m_prod, mi)",
            "\treturn x % m_prod",
            "",
            "def phi(n):",
            "\tph = [i if i & 1 else i // 2 for i in range(n + 1)]",
            "\tfor i in range(3,n+1,2):",
            "\t\tif ph[i]==i:",
            "\t\t\tfor j in range(i,n+1,i):",
            "\t\t\t\tph[j] = (ph[j]//i)*(i-1)",
            "\treturn ph"
        ],
        "description": "numrare implementation"
    },
    "SortedList": {
        "prefix": "bsortl",
        "body": [
            "from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
            "T = TypeVar('T')",
            "class SortedList(Generic[T]):",
            "\tBUCKET_RATIO = 16",
            "\tSPLIT_RATIO = 24",
            "\tdef __init__(self, a: Iterable[T] = []) -> None:",
            "\t\ta = list(a)",
            "\t\tn = self.size = len(a)",
            "\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
            "\t\t\ta.sort()",
            "\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
            "\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
            "\tdef __iter__(self) -> Iterator[T]:",
            "\t\tfor i in self.a:",
            "\t\t\tfor j in i: yield j",
            "\tdef __reversed__(self) -> Iterator[T]:",
            "\t\tfor i in reversed(self.a):",
            "\t\t\tfor j in reversed(i): yield j",
            "\tdef __eq__(self, other) -> bool:",
            "\t\treturn list(self) == list(other)",
            "\tdef __len__(self) -> int:",
            "\t\treturn self.size",
            "\tdef __repr__(self) -> str:",
            "\t\treturn \"SortedMultiset\" + str(self.a)",
            "\tdef __str__(self) -> str:",
            "\t\ts = str(list(self))",
            "\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
            "\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
            "\t\tfor i, a in enumerate(self.a):",
            "\t\t\tif x <= a[-1]: break",
            "\t\treturn (a, i, bisect_left(a, x))",
            "\tdef __contains__(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, _, i = self._position(x)",
            "\t\treturn i != len(a) and a[i] == x",
            "\tdef count(self, x: T) -> int:",
            "\t\treturn self.index_right(x) - self.index(x)",
            "\tdef insert(self, x: T) -> None:",
            "\t\tif self.size == 0:",
            "\t\t\tself.a = [[x]]",
            "\t\t\tself.size = 1",
            "\t\t\treturn",
            "\t\ta, b, i = self._position(x)",
            "\t\ta.insert(i, x)",
            "\t\tself.size += 1",
            "\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
            "\t\t\tmid = len(a) >> 1",
            "\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
            "\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
            "\t\tans = a.pop(i)",
            "\t\tself.size -= 1",
            "\t\tif not a: del self.a[b]",
            "\t\treturn ans",
            "\tdef remove(self, x: T) -> bool:",
            "\t\tif self.size == 0: return False",
            "\t\ta, b, i = self._position(x)",
            "\t\tif i == len(a) or a[i] != x: return False",
            "\t\tself._pop(a, b, i)",
            "\t\treturn True",
            "\tdef lt(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] < x:",
            "\t\t\t\treturn a[bisect_left(a, x) - 1]",
            "\tdef le(self, x: T) -> Optional[T]:",
            "\t\tfor a in reversed(self.a):",
            "\t\t\tif a[0] <= x:",
            "\t\t\t\treturn a[bisect_right(a, x) - 1]",
            "\tdef gt(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn a[bisect_right(a, x)]",
            "\tdef ge(self, x: T) -> Optional[T]:",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn a[bisect_left(a, x)]",
            "\tdef __getitem__(self, i: int) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor a in reversed(self.a):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return a[i]",
            "\t\telse:",
            "\t\t\tfor a in self.a:",
            "\t\t\t\tif i < len(a): return a[i]",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef pop(self, i: int = -1) -> T:",
            "\t\tif i < 0:",
            "\t\t\tfor b, a in enumerate(reversed(self.a)):",
            "\t\t\t\ti += len(a)",
            "\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
            "\t\telse:",
            "\t\t\tfor b, a in enumerate(self.a):",
            "\t\t\t\tif i < len(a): return self._pop(a, b, i)",
            "\t\t\t\ti -= len(a)",
            "\t\traise IndexError",
            "\tdef index(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] >= x:",
            "\t\t\t\treturn ans + bisect_left(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef index_right(self, x: T) -> int:",
            "\t\tans = 0",
            "\t\tfor a in self.a:",
            "\t\t\tif a[-1] > x:",
            "\t\t\t\treturn ans + bisect_right(a, x)",
            "\t\t\tans += len(a)",
            "\t\treturn ans",
            "\tdef find_closest(self, k: T) -> Optional[T]:",
            "\t\tif self.size == 0:",
            "\t\t\treturn None",
            "\t\tltk = self.le(k)",
            "\t\tgtk = self.ge(k)",
            "\t\tif ltk is None:",
            "\t\t\treturn gtk",
            "\t\tif gtk is None:",
            "\t\t\treturn ltk",
            "\t\tif abs(k-ltk)<=abs(k-gtk):",
            "\t\t\treturn ltk",
            "\t\telse:",
            "\t\t\treturn gtk"
        ],
        "description": "SortedList using buckets"
    },    
    "SegmentTree": {
        "prefix": "SegmentTree",
        "body": [
            "class SegmentTree:",
            "\tdef __init__(self, data, default=0, func=max):",
            "\t\t# don't forget to change func here",
            "\t\t# default is the value given to it byy default",
            "\t\tself._default = default",
            "\t\tself._func = func",
            "",
            "\t\tself._len = len(data)",
            "\t\tself._size = _size = 1 << (self._len - 1).bit_length()",
            "\t\tself._lazy = [0] * (2 * _size)",
            "",
            "\t\tself.data = [default] * (2 * _size)",
            "\t\tself.data[_size:_size + self._len] = data",
            "\t\tfor i in reversed(range(_size)):",
            "\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])",
            "\tdef __len__(self):",
            "\t\treturn self._len",
            "\tdef _push(self, idx):",
            "\t\tq, self._lazy[idx] = self._lazy[idx], 0",
            "\t\tself._lazy[2 * idx] += q",
            "\t\tself._lazy[2 * idx + 1] += q",
            "\t\tself.data[2 * idx] += q",
            "\t\tself.data[2 * idx + 1] += q",
            "\tdef _update(self, idx):",
            "\t\tfor i in reversed(range(1, idx.bit_length())):",
            "\t\t\tself._push(idx >> i)",
            "\tdef _build(self, idx):",
            "\t\tidx >>= 1",
            "\t\twhile idx:",
            "\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]",
            "\t\t\tidx >>= 1",
            "\tdef add(self, start, stop, value):",
            "\t\t# lazily add value to [start, stop)",
            "\t\tstart = start_copy = start + self._size",
            "\t\tstop = stop_copy = stop + self._size",
            "\t\twhile start < stop:",
            "\t\t\tif start & 1:",
            "\t\t\t\tself._lazy[start] += value",
            "\t\t\t\tself.data[start] += value",
            "\t\t\t\tstart += 1",
            "\t\t\tif stop & 1:",
            "\t\t\t\tstop -= 1",
            "\t\t\t\tself._lazy[stop] += value",
            "\t\t\t\tself.data[stop] += value",
            "\t\t\tstart >>= 1",
            "\t\t\tstop >>= 1",
            "\t\tself._build(start_copy)",
            "\t\tself._build(stop_copy - 1)",
            "\tdef query(self, start, stop, default=-float('inf')):",
            "\t\t# func of data[start, stop)",
            "\t\t# don't forget to update the default",
            "\t\tstart += self._size",
            "\t\tstop += self._size",
            "\t\tself._update(start)",
            "\t\tself._update(stop - 1)",
            "\t\tres = default",
            "\t\twhile start < stop:",
            "\t\t\tif start & 1:",
            "\t\t\t\tres = self._func(res, self.data[start])",
            "\t\t\t\tstart += 1",
            "\t\t\tif stop & 1:",
            "\t\t\t\tstop -= 1",
            "\t\t\t\tres = self._func(res, self.data[stop])",
            "\t\t\tstart >>= 1",
            "\t\t\tstop >>= 1",
            "\t\treturn res",
            "\tdef __repr__(self):",
            "\t\treturn \"LazySegmentTree({0})\".format(self.data)"
        ],
        "description": "Segment Tree implementation with lazy propagation in which function is assosciative"
    },
    "SegmentOther": {
        "prefix": "segmentother",
        "body": [
            "class SegmentTree:",
            "\t@staticmethod",
            "\tdef func(a, b):",
            "\t\treturn a+b",
            "\tdef __init__(self, data, default=0, mode='s'):",
            "\t\tself.mode = mode",
            "\t\tself._default = default",
            "\t\tself.n = len(data)",
            "\t\tself.size = 1 << (self.n - 1).bit_length()",
            "\t\tself.tree = [default] * (2 * self.size)",
            "\t\tself._size = [0] * (2 * self.size)",
            "\t\tself._size[self.size:] = [1] * self.size",
            "\t\tfor i in range(self.size - 1, 0, -1):",
            "\t\t\tself._size[i] = self._size[i << 1] + self._size[i << 1 | 1]",
            "\t\tself.lazy_add = 0 if self.mode == 's' else 0",
            "\t\tself.lazy_set = None",
            "\t\tself.lazy_add = [0] * self.size",
            "\t\tself.lazy_set = [None] * self.size",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.tree[self.size + i] = data[i]",
            "\t\tfor i in range(self.size - 1, 0, -1):",
            "\t\t\tself.tree[i] = self.func(self.tree[i << 1], self.tree[i << 1 | 1])",
            "\tdef _apply_set(self, pos, value):",
            "\t\tif self.mode == 's':",
            "\t\t\tself.tree[pos] = value * self._size[pos]",
            "\t\telse:",
            "\t\t\tself.tree[pos] = value",
            "\t\tif pos < self.size:",
            "\t\t\tself.lazy_set[pos] = value",
            "\t\t\tself.lazy_add[pos] = 0",
            "\tdef _apply_add(self, pos, value):",
            "\t\tif self.mode == 's':",
            "\t\t\tself.tree[pos] += value * self._size[pos]",
            "\t\telse:",
            "\t\t\tself.tree[pos] += value",
            "\t\tif pos < self.size:",
            "\t\t\tif self.lazy_set[pos] is not None:",
            "\t\t\t\tself.lazy_set[pos] += value",
            "\t\t\telse:",
            "\t\t\t\tself.lazy_add[pos] += value",
            "\tdef _build(self, pos):",
            "\t\twhile pos > 1:",
            "\t\t\tpos >>= 1",
            "\t\t\tself.tree[pos] = self.func(self.tree[pos << 1], self.tree[pos << 1 | 1])",
            "\t\t\tif self.lazy_set[pos] is not None:",
            "\t\t\t\tif self.mode == 's':",
            "\t\t\t\t\tself.tree[pos] = self.lazy_set[pos] * self._size[pos]",
            "\t\t\t\telse:",
            "\t\t\t\t\tself.tree[pos] = self.lazy_set[pos]",
            "\t\t\tif self.lazy_add[pos] != 0:",
            "\t\t\t\tif self.mode == 's':",
            "\t\t\t\t\tself.tree[pos] += self.lazy_add[pos] * self._size[pos]",
            "\t\t\t\telse:",
            "\t\t\t\t\tself.tree[pos] += self.lazy_add[pos]",
            "\tdef _push(self, pos):",
            "\t\tfor shift in range(self.size.bit_length() - 1, 0, -1):",
            "\t\t\ti = pos >> shift",
            "\t\t\tset_val = self.lazy_set[i]",
            "\t\t\tif set_val is not None:",
            "\t\t\t\tself._apply_set(i << 1, set_val)",
            "\t\t\t\tself._apply_set(i << 1 | 1, set_val)",
            "\t\t\t\tself.lazy_set[i] = None",
            "\t\t\tadd_val = self.lazy_add[i]",
            "\t\t\tif add_val != 0:",
            "\t\t\t\tself._apply_add(i << 1, add_val)",
            "\t\t\t\tself._apply_add(i << 1 | 1, add_val)",
            "\t\t\t\tself.lazy_add[i] = 0",
            "\tdef range_update(self, left, right, value,flag=True):",
            "\t\t# Range Update in [L,R] if flag, then add",
            "\t\tif flag:",
            "\t\t\tl = left + self.size",
            "\t\t\tr = right + self.size",
            "\t\t\tl0, r0 = l, r",
            "\t\t\tself._push(l0)",
            "\t\t\tself._push(r0)",
            "\t\t\twhile l <= r:",
            "\t\t\t\tif l & 1: self._apply_add(l, value); l += 1",
            "\t\t\t\tif not r & 1: self._apply_add(r, value); r -= 1",
            "\t\t\t\tl >>= 1; r >>= 1",
            "\t\t\tself._build(l0)",
            "\t\t\tself._build(r0)",
            "\t\telse:",
            "\t\t\tl = left + self.size",
            "\t\t\tr = right + self.size",
            "\t\t\tl0, r0 = l, r",
            "\t\t\tself._push(l0)",
            "\t\t\tself._push(r0)",
            "\t\t\twhile l <= r:",
            "\t\t\t\tif l & 1: self._apply_set(l, value); l += 1",
            "\t\t\t\tif not r & 1: self._apply_set(r, value); r -= 1",
            "\t\t\t\tl >>= 1; r >>= 1",
            "\t\t\tself._build(l0)",
            "\t\t\tself._build(r0)",
            "\tdef range_query(self, left, right):",
            "\t\t# Range Query in [L,R]",
            "\t\tl = left + self.size",
            "\t\tr = right + self.size",
            "\t\tself._push(l)",
            "\t\tself._push(r)",
            "\t\tres = self._default",
            "\t\twhile l <= r:",
            "\t\t\tif l & 1: res = self.func(res, self.tree[l]); l += 1",
            "\t\t\tif not r & 1: res = self.func(res, self.tree[r]); r -= 1",
            "\t\t\tl >>= 1; r >>= 1",
            "\t\treturn res",
            "\tdef __repr__(self):",
            "\t\treturn f\"SegmentTree({[self.range_query(i,i) for i in range(self.n)]})\""
        ],
        "description": "SegmentOther implementation"
    },
	"sortl": {
        "prefix": "fsortl",
        "body": [
            "class FenwickTree:",
            "\tdef __init__(self, x):",
            "\t\tbit = self.bit = list(x)",
            "\t\tsize = self.size = len(bit)",
            "\t\tfor i in range(size):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < size:",
            "\t\t\t\tbit[j] += bit[i]",
            "\tdef update(self, idx, x):",
            "\t\twhile idx < self.size:",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef __call__(self, end):",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1 ",
            "\t\treturn x",
            "\tdef find_kth(self, k):",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(self.size.bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < self.size and self.bit[right_idx] <= k:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1, k",
            "class SortedList:",
            "\tblock_size = 700",
            "\tdef __init__(self, iterable=()):",
            "\t\tself.macro = []",
            "\t\tself.micros = [[]]",
            "\t\tself.micro_size = [0]",
            "\t\tself.fenwick = FenwickTree([0])",
            "\t\tself.size = 0",
            "\t\tfor item in iterable:",
            "\t\t\tself.insert(item)",
            "\tdef insert(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\tj = bisect_right(self.micros[i], x)",
            "\t\tself.micros[i].insert(j, x)",
            "\t\tself.size += 1",
            "\t\tself.micro_size[i] += 1",
            "\t\tself.fenwick.update(i, 1)",
            "\t\tif len(self.micros[i]) >= self.block_size:",
            "\t\t\tself.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]",
            "\t\t\tself.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1",
            "\t\t\tself.fenwick = FenwickTree(self.micro_size)",
            "\t\t\tself.macro.insert(i, self.micros[i + 1][0])",
            "\tdef add(self, x):",
            "\t\tself.insert(x)",
            "\tdef pop(self, k=-1):",
            "\t\ti, j = self._find_kth(k)",
            "\t\tself.size -= 1",
            "\t\tself.micro_size[i] -= 1",
            "\t\tself.fenwick.update(i, -1)",
            "\t\treturn self.micros[i].pop(j)",
            "\tdef remove(self, N: int):",
            "\t\tidx = self.bisect_left(N)",
            "\t\tself.pop(idx)",
            "\tdef __getitem__(self, k):",
            "\t\ti, j = self._find_kth(k)",
            "\t\treturn self.micros[i][j]",
            "\tdef count(self, x):",
            "\t\treturn self.bisect_right(x) - self.bisect_left(x)",
            "\tdef __contains__(self, x):",
            "\t\treturn self.count(x) > 0",
            "\tdef bisect_left(self, x):",
            "\t\ti = bisect_left(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_left(self.micros[i], x)",
            "\tdef bisect_right(self, x):",
            "\t\ti = bisect_right(self.macro, x)",
            "\t\treturn self.fenwick(i) + bisect_right(self.micros[i], x)",
            "\tdef _find_kth(self, k):",
            "\t\treturn self.fenwick.find_kth(k + self.size if k < 0 else k)",
            "\tdef __len__(self):",
            "\t\treturn self.size",
            "\tdef __iter__(self):",
            "\t\treturn (x for micro in self.micros for x in micro)",
            "\tdef __repr__(self):",
            "\t\treturn str(list(self))"
        ],
        "description": "sorted list using fenwick tree use for insertion,deletion,traversel in log(n)"
    },
    "bootstrap": {
        "prefix": "bootstrap",
        "body": [
            "from types import GeneratorType",
            "",
            "def bootstrap(f, stack=[]):",
            "\tdef wrappedfunc(*args, **kwargs):",
            "\t\tif stack:",
            "\t\t\treturn f(*args, **kwargs)",
            "\t\telse:",
            "\t\t\tto = f(*args, **kwargs)",
            "\t\t\twhile True:",
            "\t\t\t\tif type(to) is GeneratorType:",
            "\t\t\t\t\tstack.append(to)",
            "\t\t\t\t\tto = next(to)",
            "\t\t\t\telse:",
            "\t\t\t\t\tstack.pop()",
            "\t\t\t\t\tif not stack:",
            "\t\t\t\t\t\tbreak",
            "\t\t\t\t\tto = stack[-1].send(to)",
            "\t\t\treturn to",
            "\treturn wrappedfunc",
            "",
            "# @bootstrap",
            "# put this just on top of recursion function to increase the recursion limit",
            "",
            "# rather than return now use yield and when function being called inside itself, use yield before the function name",
            "# example usage:",
            "# @bootstrap",
            "# def rec1(L,k,cur,count):",
            "# \tif count>=100000:",
            "# \t\tyield float('INF')",
            "# \tif cur+k+1>=len(L)-1:",
            "# \t\tyield L[cur]+2",
            "# \tif cur in d:",
            "# \t\tyield d[cur]",
            "# \tans = float('INF')",
            "# \tmini = float('INF')",
            "# \tfor i in range(k+1,0,-1):",
            "# \t\tif L[cur+i]<mini:",
            "# \t\t\tans = min(ans,1+L[cur]+(yield rec1(L,k,cur+i,count+1)))",
            "# \t\t\tmini = L[cur+i]",
            "# \td[cur] = ans",
            "# \tyield ans",
            "# the limit of recursion on cf is 10**6"
        ],
        "description": "Decorator to increase recursion limit using the bootstrap method with yield."
    },
    "sf": {
        "prefix": "sf",
        "body": [
            "def z_function(S):",
            "\t# return: the Z array, where Z[i] = length of the longest common prefix of S[i:] and S",
            "\tn = len(S)",
            "\tZ = [0] * n",
            "\tl = r = 0",
            "\tfor i in range(1, n):",
            "\t\tz = Z[i - l]",
            "\t\tif i + z >= r:",
            "\t\t\tz = max(r - i, 0)",
            "\t\t\twhile i + z < n and S[z] == S[i + z]:",
            "\t\t\t\tz += 1",
            "\t\t\tl, r = i, i + z",
            "\t\tZ[i] = z",
            "\tZ[0] = n",
            "\treturn Z",
            "",
            "def manacher(s):",
            "\t# returns longest palindrome in s",
            "\tt = '#' + '#'.join(s) + '#'",
            "\tn = len(t)",
            "\tL = [0] * n",
            "\tc = r = 0",
            "\tml = 0",
            "\tmc = 0",
            "\tfor i in range(n):",
            "\t\tmirror = 2*c-i",
            "\t\tif i<r:",
            "\t\t\tL[i] = min(r-i,L[mirror])",
            "\t\ta = i+L[i]+1",
            "\t\tb = i-L[i]-1",
            "\t\twhile a<n and b>=0 and t[a]==t[b]:",
            "\t\t\tL[i] += 1",
            "\t\t\ta += 1",
            "\t\t\tb -= 1",
            "\t\tif i+L[i]>r:",
            "\t\t\tc = i",
            "\t\t\tr = i+L[i]",
            "\t\tif L[i]>ml:",
            "\t\t\tml = L[i]",
            "\t\t\tmc = i",
            "\tstart = (mc-ml)//2",
            "\treturn s[start:start+ml]"
        ],
        "description": "sf implementation"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "class BIT:",
            "\t#Faster than segment tree so use if possbile",
            "\tdef __init__(self, x):",
            "\t\t\"\"\"transform list into BIT\"\"\"",
            "\t\tself.bit = x",
            "\t\tfor i in range(len(x)):",
            "\t\t\tj = i | (i + 1)",
            "\t\t\tif j < len(x):",
            "\t\t\t\tx[j] += x[i]",
            "\tdef update(self, idx, x):",
            "\t\t\"\"\"updates bit[idx] += x\"\"\"",
            "\t\t#basically after that number greater greater than x will be added",
            "\t\twhile idx < len(self.bit):",
            "\t\t\tself.bit[idx] += x",
            "\t\t\tidx |= idx + 1",
            "\tdef query(self, end):",
            "\t\t\"\"\"calc sum(bit[:end])\"\"\"",
            "\t\t#gives sum of element before end",
            "\t\tx = 0",
            "\t\twhile end:",
            "\t\t\tx += self.bit[end - 1]",
            "\t\t\tend &= end - 1",
            "\t\treturn x",
            "\tdef findkth(self, k):",
            "\t\t\"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"",
            "\t\tidx = -1",
            "\t\tfor d in reversed(range(len(self.bit).bit_length())):",
            "\t\t\tright_idx = idx + (1 << d)",
            "\t\t\tif right_idx < len(self.bit) and k >= self.bit[right_idx]:",
            "\t\t\t\tidx = right_idx",
            "\t\t\t\tk -= self.bit[idx]",
            "\t\treturn idx + 1"
        ]
    },
    "SegmentPoint": {
        "prefix": "SegmentPoint",
        "body": [
            "class SegmentTree:",
            "\t\"\"\"",
            "\t\tRemember to change the func content as well as the initializer to display the content",
            "\t\"\"\"",
            "\t@staticmethod",
            "\tdef func(a, b):",
            "\t\t# Change this function depending upon needs",
            "\t\treturn max(a, b)",
            "\tdef __init__(self, data):",
            "\t\tself.n = len(data)",
            "\t\tself.tree = [0] * (2 * self.n)",
            "\t\tself.build(data)",
            "\tdef build(self, data):",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.tree[self.n + i] = data[i]",
            "\t\tfor i in range(self.n - 1, 0, -1):",
            "\t\t\tself.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1])",
            "\tdef update(self, pos, value):",
            "\t\t# Update the value at the leaf node",
            "\t\tpos += self.n",
            "\t\t# For updating",
            "\t\tself.tree[pos] = value",
            "\t\t# self.tree[pos] += value",
            "\t\t# If you want to add rather than update",
            "\t\twhile pos > 1:",
            "\t\t\tpos //= 2",
            "\t\t\tself.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1])",
            "\tdef query(self, left, right):",
            "\t\t# Query the maximum value in the range [left, right)",
            "\t\tleft += self.n",
            "\t\tright += self.n",
            "\t\t# Change the initializer depending upon the self.func",
            "\t\tmax_val = float('-inf')",
            "\t\t##",
            "\t\twhile left < right:",
            "\t\t\tif left % 2:",
            "\t\t\t\tmax_val = self.func(max_val, self.tree[left])",
            "\t\t\t\tleft += 1",
            "\t\t\tif right % 2:",
            "\t\t\t\tright -= 1",
            "\t\t\t\tmax_val = self.func(max_val, self.tree[right])",
            "\t\t\tleft //= 2",
            "\t\t\tright //= 2",
            "\t\treturn max_val",
            "\tdef __repr__(self):",
            "\t\tvalues = [str(self.query(i, i + 1)) for i in range(self.n)]",
            "\t\treturn f'Seg[{', '.join(values)}]'"
        ],
        "description": "Segment Tree implementation better for point updates and range queries"
    },
    "SparseTable": {
        "prefix": "SparseTable",
        "body": [
            "class SparseTable:",
            "\t@staticmethod",
            "\tdef func(a,b):",
            "\t\t# func(a,a) should be a",
            "\t\treturn gcd(a,b)",
            "\tdef __init__(self, arr):",
            "\t\tself.n = len(arr)",
            "\t\tself.table = [[0 for i in range(int((math.log(self.n, 2)+1)))] for j in range(self.n)]",
            "\t\tself.build(arr)",
            "\tdef build(self, arr):",
            "\t\tfor i in range(0, self.n):",
            "\t\t\tself.table[i][0] = arr[i]",
            "\t\tj = 1",
            "\t\twhile (1 << j) <= self.n:",
            "\t\t\ti = 0",
            "\t\t\twhile i <= self.n - (1 << j):",
            "\t\t\t\tself.table[i][j] = self.func(self.table[i][j - 1], self.table[i + (1 << (j - 1))][j - 1])",
            "\t\t\t\ti += 1",
            "\t\t\tj += 1",
            "\tdef query(self, L, R):",
            "\t\t# query from [L,R]",
            "\t\tj = int(math.log2(R - L + 1))",
            "\t\treturn self.func(self.table[L][j], self.table[R - (1 << j) + 1][j])"
        ],
        "description": "Sparse Table"
    },
    "dpheq": {
        "prefix": "dpheq",
        "body": [
            "class DiophantineEquations:",
            "\t\"\"\"",
            "\t\tused for solving equations of the form a*x + b*y = c,",
            "\t\tsolnll takes the lower limit as well",
            "\t\"\"\"",
            "\tdef __init__(self):",
            "\t\tpass",
            "\tdef euclidean_gcd(self,a, b):",
            "\t\t\"\"\"",
            "\t\t\teuclidean gcd , returns x and y such that",
            "\t\t\ta*x + b*y = gcd(a,b)",
            "\t\t\"\"\"",
            "\t\tif b == 0:",
            "\t\t\treturn a,1,0",
            "\t\tg,x1,y1 = self.euclidean_gcd(b, a % b)",
            "\t\tx = y1",
            "\t\ty = x1-(a//b)*y1",
            "\t\treturn g,x,y",
            "\tdef soln(self,a,b,c,t=10**18,t1=10**18):",
            "\t\t\"\"\"",
            "\t\t\treturn m and n such that a*m + b*n = c and 0<=m<=t and 0<=n<=t1",
            "\t\t\tdon't input t,t1 for any possible value",
            "\t\t\"\"\"",
            "\t\tg = gcd(a, b)",
            "\t\tif c%g!=0:",
            "\t\t\treturn -1,-1",
            "\t\t_, x, y = self.euclidean_gcd(a, b)",
            "\t\tk3 = x*(c//g)",
            "\t\tn1 = y*(c//g)",
            "\t\tk1 = max(math.ceil(-k3*g/b),math.ceil((n1-t1)/(a/g)))",
            "\t\tkmaxi = min(math.floor((t-k3)/(b/g)), math.floor(n1/(a/g)))",
            "\t\tif k1<=kmaxi:",
            "\t\t\tk = k1",
            "\t\t\tm = k3+k*(b//g)",
            "\t\t\tn = n1-k*(a//g)",
            "\t\t\treturn m, n",
            "\t\telse:",
            "\t\t\treturn -1,-1",
            "\tdef sollnll(self,a,b,c,t,t1,m_lower,n_lower):",
            "\t\t\"\"\"",
            "\t\t\treturn m and n such that a*m + b*n = c and",
            "\t\t\tm_lower <= m <= t and n_lower <= n <= t1",
            "\t\t\"\"\"",
            "\t\tg = gcd(a, b)",
            "\t\tif c % g != 0:",
            "\t\t\treturn -1, -1",
            "\t\t_, x, y = self.euclidean_gcd(a, b)",
            "\t\tk3 = x * (c // g)",
            "\t\tn1 = y * (c // g)",
            "\t\tk1 = max(math.ceil((m_lower - k3 * g) / b), math.ceil((n1 - t1) / (a / g)))",
            "\t\tkmaxi = min(math.floor((t - k3) / (b / g)), math.floor((n1 - n_lower) / (a / g)))",
            "\t\tif k1 <= kmaxi:",
            "\t\t\tk = k1",
            "\t\t\tm = k3 + k * (b // g)",
            "\t\t\tn = n1 - k * (a // g)",
            "\t\t\tif m_lower <= m <= t and n_lower <= n <= t1:",
            "\t\t\t\treturn m, n",
            "\t\t\telse:",
            "\t\t\t\treturn -1,-1",
            "\t\telse:",
            "\t\t\treturn -1, -1",
            "Leq = DiophantineEquations()"
        ],
        "description": "dpheq implementation"
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "class UnionFind:",
            "\tdef __init__(self, n):",
            "\t\tself.parent = list(range(n))",
            "",
            "\tdef find(self, a):",
            "\t\tacopy = a",
            "\t\twhile a != self.parent[a]:",
            "\t\t\ta = self.parent[a]",
            "\t\twhile acopy != a:",
            "\t\t\tself.parent[acopy], acopy = a, self.parent[acopy]",
            "\t\treturn a",
            "",
            "\tdef union(self, a, b):",
            "\t\tself.parent[self.find(b)] = self.find(a)",
            "",
            "",
            "class DisjointSetUnion:",
            "\tdef __init__(self, n):",
            "\t\tself.parent = list(range(n))",
            "\t\t# self.s = set(self.parent)",
            "\t\tself.size = [1] * n",
            "",
            "\tdef find(self, a):",
            "\t\tacopy = a",
            "\t\twhile a != self.parent[a]:",
            "\t\t\ta = self.parent[a]",
            "\t\twhile acopy != a:",
            "\t\t\tself.parent[acopy], acopy = a, self.parent[acopy]",
            "\t\treturn a",
            "",
            "\tdef union(self, a, b):",
            "\t\ta, b = self.find(a), self.find(b)",
            "\t\tif a != b:",
            "\t\t\tif self.size[a] < self.size[b]:",
            "\t\t\t\ta, b = b, a",
            "\t\t\t# self.s.remove(b)",
            "\t\t\tself.parent[b] = a",
            "\t\t\tself.size[a] += self.size[b]",
            "",
            "\tdef set_size(self, a):",
            "\t\treturn self.size[self.find(a)]",
            "",
            "\tdef __len__(self):",
            "\t\treturn len(self.s)",
            "",
            "\tdef notfind(self, a):",
            "\t\tk = self.find(a)",
            "\t\tfor j in self.s:",
            "\t\t\tif j!=k:",
            "\t\t\t\treturn j",
            "\t\treturn -1"
            
        ],
        "description": "DSU implementation"
    },
    "shclass": {
        "prefix": "shclass",
        "body": [
            "HMOD = 2147483647",
            "HBASE1 = random.randrange(HMOD)",
            "HBASE2 = random.randrange(HMOD)",
            "class Hashing:",
            "\tdef __init__(self, s, mod=HMOD, base1=HBASE1, base2=HBASE2):",
            "\t\tself.mod, self.base1, self.base2 = mod, base1, base2",
            "\t\tself._len = _len = len(s)",
            "\t\tf_hash, f_pow = [0] * (_len + 1), [1] * (_len + 1)",
            "\t\ts_hash, s_pow = f_hash[:], f_pow[:]",
            "\t\tfor i in range(_len):",
            "\t\t\tf_hash[i + 1] = (base1 * f_hash[i] + s[i]) % mod",
            "\t\t\ts_hash[i + 1] = (base2 * s_hash[i] + s[i]) % mod",
            "\t\t\tf_pow[i + 1] = base1 * f_pow[i] % mod",
            "\t\t\ts_pow[i + 1] = base2 * s_pow[i] % mod",
            "\t\tself.f_hash, self.f_pow = f_hash, f_pow",
            "\t\tself.s_hash, self.s_pow = s_hash, s_pow",
            "\tdef hashed(self, start, stop):",
            "\t\treturn (",
            "\t\t\t(self.f_hash[stop] - self.f_pow[stop - start] * self.f_hash[start]) % self.mod,",
            "\t\t\t(self.s_hash[stop] - self.s_pow[stop - start] * self.s_hash[start]) % self.mod,",
            "\t\t)",
            "\tdef get_hashes(self, length):",
            "\t\treturn (",
            "\t\t\t[(self.f_hash[i + length] - self.f_pow[length] * self.f_hash[i]) % self.mod for i in range(self._len - length + 1)],",
            "\t\t\t[(self.s_hash[i + length] - self.s_pow[length] * self.s_hash[i]) % self.mod for i in range(self._len - length + 1)],",
            "\t\t)"
        ],
        "description": "shclass implementation"
    },
    "Geometry": {
        "prefix": "geometry",
        "body": [
            "## here onwards, it is for intersection only, even the point class is different",
            "class Point:",
            "\tdef __init__(self, x, y):",
            "\t\tself.x = x",
            "\t\tself.y = y",
            "def onSegment(p, q, r):",
            "\tif ( (q.x <= max(p.x, r.x)) and (q.x >= min(p.x, r.x)) and",
            "\t\t   (q.y <= max(p.y, r.y)) and (q.y >= min(p.y, r.y))):",
            "\t\treturn True",
            "\treturn False",
            "def orientation(p, q, r):",
            "\t# to find the orientation of an ordered triplet (p,q,r)",
            "\t# function returns the following values:",
            "\t# 0 : Collinear points",
            "\t# 1 : Clockwise points",
            "\t# 2 : Counterclockwise",
            "\tval = ((q.y - p.y) * (r.x - q.x)) - ((q.x - p.x) * (r.y - q.y))",
            "\tif (val > 0):",
            "\t\treturn 1",
            "\telif (val < 0):",
            "\t\treturn 2",
            "\telse:",
            "\t\treturn 0",
            "def doIntersect(p1,q1,p2,q2):",
            "\to1 = orientation(p1, q1, p2)",
            "\to2 = orientation(p1, q1, q2)",
            "\to3 = orientation(p2, q2, p1)",
            "\to4 = orientation(p2, q2, q1)",
            "\tif ((o1 != o2) and (o3 != o4)):",
            "\t\treturn True",
            "\tif ((o1 == 0) and onSegment(p1, p2, q1)):",
            "\t\treturn True",
            "\tif ((o2 == 0) and onSegment(p1, q2, q1)):",
            "\t\treturn True",
            "\tif ((o3 == 0) and onSegment(p2, p1, q2)):",
            "\t\treturn True",
            "\tif ((o4 == 0) and onSegment(p2, q1, q2)):",
            "\t\treturn True",
            "\treturn False",
            "##",
            "## lines",
            "# 2d line: ax + by + c = 0  is  (a, b, c)",
            "#\t\t  ax + by + c = 0\t ((a, b, c),",
            "# 3d line: dx + ez + f = 0  is  (d, e, f),",
            "#\t\t  gy + hz + i = 0\t  (g, h, i))",
            "",
            "def get_2dline(p1, p2):",
            "\tif p1 == p2:",
            "\t\treturn (0, 0, 0)",
            "\t_p1, _p2 = min(p1, p2), max(p1, p2)",
            "\ta, b, c = _p2[1] - _p1[1], _p1[0] - _p2[0], _p1[1] * _p2[0] - _p1[0] * _p2[1]",
            "\tg = gcd(gcd(a, b), c)",
            "\treturn (a // g, b // g, c // g)",
            "dist = lambda p1, p2: sum((a - b) * (a - b) for a, b in zip(p1, p2))**0.5",
            "get_line = lambda p1, p2: map(get_2dline, combinations(p1, 2), combinations(p2, 2))",
            "is_parallel = lambda l1, l2: l1[0] * l2[1] == l2[0] * l1[1]",
            "is_same = lambda l1, l2: is_parallel(l1, l2) and (l1[1] * l2[2] == l2[1] * l1[2])",
            "collinear = lambda p1, p2, p3: is_same(get_2dline(p1, p2), get_2dline(p2, p3))",
            "intersect = (lambda l1, l2: None if is_parallel(l1, l2) else (",
            "\t(l2[1] * l1[2] - l1[1] * l2[2]) / (l2[0] * l1[1] - l1[0] * l2[1]),",
            "\t(l1[0] * l2[2] - l1[2] * l2[0]) / (l2[0] * l1[1] - l1[0] * l2[1]),",
            "))",
            "rotate = lambda p, theta, origin=(0, 0): (",
            "\torigin[0] + (p[0] - origin[0]) * math.cos(theta) - (p[1] - origin[1]) * math.sin(theta),",
            "\torigin[1] + (p[0] - origin[0]) * math.sin(theta) + (p[1] - origin[1]) * math.cos(theta),",
            ")",
            "##",
            "## polygons",
            "dist = lambda p1, p2: sum((a - b) * (a - b) for a, b in zip(p1, p2))**0.5",
            "perimeter = lambda *p: sum(dist(i, j) for i, j in zip(p, p[1:] + p[:1]))",
            "area = lambda *p: abs(sum(i[0] * j[1] - j[0] * i[1] for i, j in zip(p, p[1:] + p[:1]))) / 2",
            "is_in_circle = lambda p, c, r: sum(i * i - j * j for i, j in zip(p, c)) < r * r",
            "incircle_radius = lambda a, b, c: area(a, b, c) / (perimeter(a, b, c) / 2)",
            "circumcircle_radius = lambda a, b, c: (dist(a, b) * dist(b, c) * dist(c, a)) / (4 * area(a, b, c))",
            "##"
        ],
        "description": "Geometry implementation"
    },
    "Tries": {
        "prefix": "tries",
        "body": [
            "",
            "class Trie:",
            "\tdef __init__(self, *words):",
            "\t\tself.root = {}",
            "\t\tfor word in words:",
            "\t\t\tself.add(word)",
            "",
            "\tdef add(self, word):",
            "\t\tcurrent_dict = self.root",
            "\t\tfor letter in word:",
            "\t\t\tcurrent_dict = current_dict.setdefault(letter, {})",
            "\t\tcurrent_dict[0] = True",
            "",
            "\tdef __contains__(self, word):",
            "\t\tcurrent_dict = self.root",
            "\t\tfor letter in word:",
            "\t\t\tif letter not in current_dict:",
            "\t\t\t\treturn False",
            "\t\t\tcurrent_dict = current_dict[letter]",
            "\t\treturn 0 in current_dict",
            "",
            "\tdef __delitem__(self, word):",
            "\t\tcurrent_dict = self.root",
            "\t\tnodes = [current_dict]",
            "\t\tfor letter in word:",
            "\t\t\tcurrent_dict = current_dict[letter]",
            "\t\t\tnodes.append(current_dict)",
            "\t\tdel current_dict[0]"
        ],
        "description": "Tries implementation"
    },
    "FFT": {
        "prefix": "fft",
        "body": [
            "class FastFFT:",
            "\t# This is a bit faster, one log n factor is less but it's accuracy is not 100%",
            "\t# use this when coeffecient does not matter(set coeffecient to 1 repeatedly)",
            "\t# or you could just risk it :)",
            "\tdef __init__(self, MOD=998244353):",
            "\t\tFastFFT.MOD = MOD",
            "\t\t# g = self.primitive_root_constexpr()",
            "\t\tg = 3",
            "\t\tig = pow(g, FastFFT.MOD - 2, FastFFT.MOD)",
            "\t\tFastFFT.W = [pow(g, (FastFFT.MOD - 1) >> i, FastFFT.MOD) for i in range(30)]",
            "\t\tFastFFT.iW = [pow(ig, (FastFFT.MOD - 1) >> i, FastFFT.MOD) for i in range(30)]",
            "\tdef primitive_root_constexpr(self):",
            "\t\tif FastFFT.MOD == 998244353:",
            "\t\t\treturn 3",
            "\t\telif FastFFT.MOD == 200003:",
            "\t\t\treturn 2",
            "\t\telif FastFFT.MOD == 167772161:",
            "\t\t\treturn 3",
            "\t\telif FastFFT.MOD == 469762049:",
            "\t\t\treturn 3",
            "\t\telif FastFFT.MOD == 754974721:",
            "\t\t\treturn 11",
            "\t\tdivs = [0] * 20",
            "\t\tdivs[0] = 2",
            "\t\tcnt = 1",
            "\t\tx = (FastFFT.MOD - 1) // 2",
            "\t\twhile x % 2 == 0:",
            "\t\t\tx //= 2",
            "\t\ti = 3",
            "\t\twhile i * i <= x:",
            "\t\t\tif x % i == 0:",
            "\t\t\t\tdivs[cnt] = i",
            "\t\t\t\tcnt += 1",
            "\t\t\t\twhile x % i == 0:",
            "\t\t\t\t\tx //= i",
            "\t\t\ti += 2",
            "\t\tif x > 1:",
            "\t\t\tdivs[cnt] = x",
            "\t\t\tcnt += 1",
            "\t\tg = 2",
            "\t\twhile 1:",
            "\t\t\tok = True",
            "\t\t\tfor i in range(cnt):",
            "\t\t\t\tif pow(g, (FastFFT.MOD - 1) // divs[i], FastFFT.MOD) == 1:",
            "\t\t\t\t\tok = False",
            "\t\t\t\t\tbreak",
            "\t\t\tif ok:",
            "\t\t\t\treturn g",
            "\t\t\tg += 1",
            "\tdef fft(self, k, f):",
            "\t\tfor l in range(k, 0, -1):",
            "\t\t\td = 1 << l - 1",
            "\t\t\tU = [1]",
            "\t\t\tfor i in range(d):",
            "\t\t\t\tU.append(U[-1] * FastFFT.W[l] % FastFFT.MOD)",
            "\t\t\tfor i in range(1 << k - l):",
            "\t\t\t\tfor j in range(d):",
            "\t\t\t\t\ts = i * 2 * d + j",
            "\t\t\t\t\tf[s], f[s + d] = (f[s] + f[s + d]) % FastFFT.MOD, U[j] * (f[s] - f[s + d]) % FastFFT.MOD",
            "\tdef ifft(self, k, f):",
            "\t\tfor l in range(1, k + 1):",
            "\t\t\td = 1 << l - 1",
            "\t\t\tfor i in range(1 << k - l):",
            "\t\t\t\tu = 1",
            "\t\t\t\tfor j in range(i * 2 * d, (i * 2 + 1) * d):",
            "\t\t\t\t\tf[j+d] *= u",
            "\t\t\t\t\tf[j], f[j + d] = (f[j] + f[j + d]) % FastFFT.MOD, (f[j] - f[j + d]) % FastFFT.MOD",
            "\t\t\t\t\tu = u * FastFFT.iW[l] % FastFFT.MOD",
            "\tdef convolve(self, A, B):",
            "\t\tn0 = len(A) + len(B) - 1",
            "\t\tk = (n0).bit_length()",
            "\t\tn = 1 << k",
            "\t\tA += [0] * (n - len(A))",
            "\t\tB += [0] * (n - len(B))",
            "\t\tself.fft(k, A)",
            "\t\tself.fft(k, B)",
            "\t\tA = [a * b % FastFFT.MOD for a, b in zip(A, B)]",
            "\t\tself.ifft(k, A)",
            "\t\tinv = pow(n, FastFFT.MOD - 2, FastFFT.MOD)",
            "\t\tdel A[n0:]",
            "\t\tfor i in range(n0):",
            "\t\t\tA[i] = (A[i]*inv)%FastFFT.MOD",
            "\t\treturn A",
            "",
            "class FFT:",
            "\tdef __init__(self, MOD=998244353,MOD1=469762049):",
            "\t\tFFT.MOD = MOD",
            "\t\tFFT.MOD1 = MOD1",
            "\t\tFFT.MOD2 = pow(MOD,MOD1-2,MOD1)",
            "\t\tFFT.mod_inv = (self.XT_GCD(MOD,MOD1)[1])%MOD1",
            "\t\t# g = self.primitive_root_constexpr()",
            "\t\tg = 3",
            "\t\tig = pow(g, FFT.MOD - 2, FFT.MOD)",
            "\t\tig1 = pow(g, FFT.MOD1 - 2, FFT.MOD1)",
            "\t\tFFT.W = [pow(g, (FFT.MOD - 1) >> i, FFT.MOD) for i in range(30)]",
            "\t\tFFT.W1 = [pow(g, (FFT.MOD1 - 1) >> i, FFT.MOD1) for i in range(30)]",
            "\t\tFFT.iW = [pow(ig, (FFT.MOD - 1) >> i, FFT.MOD) for i in range(30)]",
            "\t\tFFT.iW1 = [pow(ig1, (FFT.MOD1 - 1) >> i, FFT.MOD1) for i in range(30)]",
            "\tdef primitive_root_constexpr(self):",
            "\t\tif FFT.MOD == 998244353:",
            "\t\t\treturn 3",
            "\t\telif FFT.MOD == 200003:",
            "\t\t\treturn 2",
            "\t\telif FFT.MOD == 167772161:",
            "\t\t\treturn 3",
            "\t\telif FFT.MOD == 469762049:",
            "\t\t\treturn 3",
            "\t\telif FFT.MOD == 754974721:",
            "\t\t\treturn 11",
            "\t\tdivs = [0] * 20",
            "\t\tdivs[0] = 2",
            "\t\tcnt = 1",
            "\t\tx = (FFT.MOD - 1) // 2",
            "\t\twhile x % 2 == 0:",
            "\t\t\tx //= 2",
            "\t\ti = 3",
            "\t\twhile i * i <= x:",
            "\t\t\tif x % i == 0:",
            "\t\t\t\tdivs[cnt] = i",
            "\t\t\t\tcnt += 1",
            "\t\t\t\twhile x % i == 0:",
            "\t\t\t\t\tx //= i",
            "\t\t\ti += 2",
            "\t\tif x > 1:",
            "\t\t\tdivs[cnt] = x",
            "\t\t\tcnt += 1",
            "\t\tg = 2",
            "\t\twhile 1:",
            "\t\t\tok = True",
            "\t\t\tfor i in range(cnt):",
            "\t\t\t\tif pow(g, (FFT.MOD - 1) // divs[i], FFT.MOD) == 1:",
            "\t\t\t\t\tok = False",
            "\t\t\t\t\tbreak",
            "\t\t\tif ok:",
            "\t\t\t\treturn g",
            "\t\t\tg += 1",
            "\tdef fft(self, k, f,f1):",
            "\t\tfor l in range(k, 0, -1):",
            "\t\t\td = 1 << l - 1",
            "\t\t\tU = [(1,1)]",
            "\t\t\tfor i in range(d):",
            "\t\t\t\tU.append((U[-1][0] * FFT.W[l] % FFT.MOD,U[-1][1] * FFT.W1[l] % FFT.MOD1))",
            "\t\t\tfor i in range(1 << k - l):",
            "\t\t\t\tfor j in range(d):",
            "\t\t\t\t\ts = i * 2 * d + j",
            "\t\t\t\t\tf[s], f[s + d] = (f[s] + f[s + d]) % FFT.MOD, U[j][0] * (f[s] - f[s + d]) % FFT.MOD",
            "\t\t\t\t\tf1[s], f1[s + d] = (f1[s] + f1[s + d]) % FFT.MOD1, U[j][1] * (f1[s] - f1[s + d]) % FFT.MOD1",
            "\tdef ifft(self, k, f,f1):",
            "\t\tfor l in range(1, k + 1):",
            "\t\t\td = 1 << l - 1",
            "\t\t\tfor i in range(1 << k - l):",
            "\t\t\t\tu = 1",
            "\t\t\t\tu1 = 1",
            "\t\t\t\tfor j in range(i * 2 * d, (i * 2 + 1) * d):",
            "\t\t\t\t\tf[j+d] *= u",
            "\t\t\t\t\tf[j], f[j + d] = (f[j] + f[j + d]) % FFT.MOD, (f[j] - f[j + d]) % FFT.MOD",
            "\t\t\t\t\tu = u * FFT.iW[l] % FFT.MOD",
            "\t\t\t\t\tf1[j+d] *= u1",
            "\t\t\t\t\tf1[j], f1[j + d] = (f1[j] + f1[j + d]) % FFT.MOD1, (f1[j] - f1[j + d]) % FFT.MOD1",
            "\t\t\t\t\tu1 = u1 * FFT.iW1[l] % FFT.MOD1",
            "\tdef XT_GCD(self,a,b):",
            "\t\tif b == 0:",
            "\t\t\treturn a,1,0",
            "\t\tg,x1,y1 = self.XT_GCD(b,a%b)",
            "\t\tx = y1",
            "\t\ty = x1-(a//b)*y1",
            "\t\treturn g,x,y",
            "\tdef CRT(self,a, mod1, b, mod2):",
            "\t\tk = (a+(b-a)*self.mod_inv%mod2*mod1)%(mod1*mod2)",
            "\t\treturn k",
            "\tdef convolve(self, A, B):",
            "\t\tn0 = len(A) + len(B) - 1",
            "\t\tk = (n0).bit_length()",
            "\t\tn = 1 << k",
            "\t\tA += [0] * (n - len(A))",
            "\t\tB += [0] * (n - len(B))",
            "\t\tA1 = A[:]",
            "\t\tB1 = B[:]",
            "\t\tself.fft(k, A,A1)",
            "\t\tself.fft(k, B,B1)",
            "\t\tA = [a * b % FFT.MOD for a, b in zip(A, B)]",
            "\t\tA1 = [a * b % FFT.MOD1 for a, b in zip(A1, B1)]",
            "\t\tself.ifft(k, A,A1)",
            "\t\tinv = pow(n, FFT.MOD - 2, FFT.MOD)",
            "\t\tinv1 = pow(n, FFT.MOD1 - 2, FFT.MOD1)",
            "\t\tdel A[n0:]",
            "\t\tfor i in range(n0):",
            "\t\t\tA[i] = self.CRT(A[i]*inv,FFT.MOD,A1[i]*inv1,FFT.MOD1)",
            "\t\treturn A",
            ""
        ],
        "description": "FFT implementation"
    },
    "perseg": {
        "prefix": "perseg",
        "body": [
            "class PersistentSegmentTree:",
            "",
            "\tclass Node:",
            "\t\tdef __init__(self, value=0, left=None, right=None):",
            "\t\t\tself.value = value",
            "\t\t\tself.left = left",
            "\t\t\tself.right = right",
            "",
            "\t@staticmethod",
            "\tdef func(a, b):",
            "\t\treturn a+b",
            "\tdef __init__(self, data):",
            "\t\tself.n = len(data)",
            "\t\tself.versions = []",
            "\t\tself.versions.append(self._build(data))",
            "\tdef _build(self, data):",
            "\t\tstack = [(0, self.n - 1, False)]",
            "\t\tnodes = {}",
            "\t\twhile stack:",
            "\t\t\tleft, right, visited = stack.pop()",
            "\t\t\tif left == right:",
            "\t\t\t\tnodes[(left, right)] = self.Node(data[left])",
            "\t\t\telse:",
            "\t\t\t\tif visited:",
            "\t\t\t\t\tmid = (left + right) // 2",
            "\t\t\t\t\tleft_child = nodes[(left, mid)]",
            "\t\t\t\t\tright_child = nodes[(mid + 1, right)]",
            "\t\t\t\t\tnodes[(left, right)] = self.Node(self.func(left_child.value,right_child.value),left_child, right_child)",
            "\t\t\t\telse:",
            "\t\t\t\t\tstack.append((left, right, True))",
            "\t\t\t\t\tmid = (left + right) // 2",
            "\t\t\t\t\tstack.append((mid + 1, right, False))",
            "\t\t\t\t\tstack.append((left, mid, False))",
            "\t\treturn nodes[(0, self.n - 1)]",
            "",
            "\tdef update(self, version, pos, value):",
            "\t\told_root = self.versions[version]",
            "\t\tstack, path = [(old_root, 0, self.n - 1)], []",
            "\t\twhile stack:",
            "\t\t\tnode, left, right = stack.pop()",
            "\t\t\tpath.append((node, left, right))",
            "\t\t\tif left == right:",
            "\t\t\t\tbreak",
            "\t\t\tmid = (left + right) // 2",
            "\t\t\tif pos <= mid:",
            "\t\t\t\tstack.append((node.left, left, mid))",
            "\t\t\telse:",
            "\t\t\t\tstack.append((node.right, mid + 1, right))",
            "",
            "\t\tnew_nodes = {}",
            "\t\tfor node, left, right in reversed(path):",
            "\t\t\tif left == right:",
            "\t\t\t\tk = value",
            "\t\t\t\t# k = self.func(node.value,value) # if i want to update",
            "\t\t\t\tnew_nodes[(left, right)] = self.Node(k)",
            "\t\t\telse:",
            "\t\t\t\tmid = (left + right) // 2",
            "\t\t\t\tleft_child = new_nodes.get((left, mid), node.left)",
            "\t\t\t\tright_child = new_nodes.get((mid + 1, right), node.right)",
            "\t\t\t\tnew_nodes[(left, right)] = self.Node(self.func(left_child.value,right_child.value),left_child, right_child)",
            "\t\treturn new_nodes[(0, self.n - 1)]",
            "",
            "\tdef create_version(self, version, pos, value):",
            "\t\tnew_root = self.update(version, pos, value)",
            "\t\tself.versions.append(new_root)",
            "\t\treturn len(self.versions) - 1",
            "",
            "\tdef query(self, version, ql, qr):",
            "\t\tnode, left, right = self.versions[version], 0, self.n - 1",
            "\t\tstack = [(node, left, right)]",
            "\t\tresult = 0 # change this depending on the problem",
            "\t\twhile stack:",
            "\t\t\tnode, left, right = stack.pop()",
            "\t\t\tif ql > right or qr < left:",
            "\t\t\t\tcontinue",
            "\t\t\tif ql <= left and right <= qr:",
            "\t\t\t\tresult = self.func(result,node.value)",
            "\t\t\telse:",
            "\t\t\t\tmid = (left + right) // 2",
            "\t\t\t\tstack.append((node.left, left, mid))",
            "\t\t\t\tstack.append((node.right, mid + 1, right))",
            "\t\treturn result"
        ],
        "description": "Persistent Segment Tree implementation"
    },
    "Binary Trie": {
        "prefix": "b_trie",
        "body": [
            "class Node():",
            "\tdef __init__(self):",
            "\t\tself.data=0",
            "\t\tself.left=None",
            "\t\tself.right=None",
            "\t\tself.count=0",
            "class Trie():",
            "\tdef __init__(self,k=30):",
            "\t\tself.root=Node()",
            "\t\tself.k = k",
            "\tdef add(self,val):",
            "\t\tself.temp=self.root",
            "\t\tfor i in range(self.k,-1,-1):",
            "\t\t\tif (val)&(1<<i):",
            "\t\t\t\tif not self.temp.right:",
            "\t\t\t\t\tself.temp.right=Node()",
            "\t\t\t\tself.temp=self.temp.right",
            "\t\t\t\tself.temp.count+=1",
            "\t\t\telse:",
            "\t\t\t\tif not self.temp.left:",
            "\t\t\t\t\tself.temp.left=Node()",
            "\t\t\t\tself.temp=self.temp.left",
            "\t\t\t\tself.temp.count+=1",
            "\t\tself.temp.data=val",
            "\tdef __delitem__(self,val):",
            "\t\tself.temp=self.root",
            "\t\tfor i in range(self.k,-1,-1):",
            "\t\t\tif val&(1<<i):",
            "\t\t\t\tself.temp=self.temp.right",
            "\t\t\t\tself.temp.count-=1",
            "\t\t\telse:",
            "\t\t\t\tself.temp=self.temp.left",
            "\t\t\t\tself.temp.count-=1",
            "\tdef query_max(self,val):",
            "\t\tself.temp=self.root",
            "\t\tfor i in range(self.k,-1,-1):",
            "\t\t\tif val&(1<<i):",
            "\t\t\t\tif self.temp.left and self.temp.left.count>0:",
            "\t\t\t\t\tself.temp=self.temp.left",
            "\t\t\t\telif self.temp.right and self.temp.right.count>0:",
            "\t\t\t\t\tself.temp=self.temp.right",
            "\t\t\telse:",
            "\t\t\t\tif self.temp.right and self.temp.right.count>0:",
            "\t\t\t\t\tself.temp=self.temp.right",
            "\t\t\t\telif self.temp.left and self.temp.left.count>0:",
            "\t\t\t\t\tself.temp=self.temp.left",
            "\t\treturn val^self.temp.data",
            "\tdef query_min(self,val):",
            "\t\tself.temp=self.root",
            "\t\tfor i in range(self.k,-1,-1):",
            "\t\t\tif val&(1<<i)==0:",
            "\t\t\t\tif self.temp.left and self.temp.left.count>0:",
            "\t\t\t\t\tself.temp=self.temp.left",
            "\t\t\t\telif self.temp.right and self.temp.right.count>0:",
            "\t\t\t\t\tself.temp=self.temp.right",
            "\t\t\telse:",
            "\t\t\t\tif self.temp.right and self.temp.right.count>0:",
            "\t\t\t\t\tself.temp=self.temp.right",
            "\t\t\t\telif self.temp.left and self.temp.left.count>0:",
            "\t\t\t\t\tself.temp=self.temp.left",
            "\t\treturn val^self.temp.data"
        ],
        "description": "Binary Trie implementation"
    },
    "xdict": {
        "prefix": "xdict",
        "body": [
            "class Xdict:",
            "\tdef __init__(self):",
            "\t\tself.d = {}",
            "\tdef __setitem__(self,key,value):",
            "\t\tself.d[w(key)] = value",
            "\tdef __getitem__(self,key):",
            "\t\treturn self.d[w(key)]",
            "\tdef keys(self):",
            "\t\treturn (w(i) for i in self.d)",
            "\tdef values(self):",
            "\t\treturn (self.d[i] for i in self.d)",
            "\tdef items(self):",
            "\t\treturn ((w(i),self.d[i]) for i in self.d)",
            "\tdef __repr__(self):",
            "\t\treturn '{'+','.join([str(w(i))+':'+str(self.d[i]) for i in self.d])+'}'",
            "\tdef __delitem__(self,val):",
            "\t\tdel self.d[w(val)]",
            "\tdef get(self,key,other):",
            "\t\treturn self.d.get(w(key),other)",
            "\tdef __contains__(self,key):",
            "\t\treturn w(key) in self.d",
            "\tdef __len__(self):",
            "\t\treturn len(self.d)",
            "\tdef clear(self):",
            "\t\tself.d.clear()",
            "\tdef __iter__(self):",
            "\t\treturn iter(self.keys())"
        ],
        "description": "xdict implementation"
    }, 
    "hld": {
        "prefix": "hld",
        "body": [
            "class HLD:",
            "\tdef __init__(self, adj, values, root=0,func=max,unit=float('-inf')):",
            "\t\tself.adj = adj",
            "\t\tself.values = values",
            "\t\tself.parent = [-1] * len(adj)",
            "\t\tself.depth = [0] * len(adj)",
            "\t\tself.size = [0] * len(adj)",
            "\t\tself.heavy = [-1] * len(adj)",
            "\t\tself.head = [0] * len(adj)",
            "\t\tself.pos = [0] * len(adj)",
            "\t\tself.flat = [0] * len(adj)",
            "\t\tself.unit = unit",
            "\t\tself.func = func",
            "\t\tself._dfs(root)",
            "\t\tself._decompose(root)",
            "\t\tself.seg = SegmentTree([self.values[self.flat[i]] for i in range(len(self.adj))],func,unit)",
            "\tdef _dfs(self,start=0):",
            "\t\tvisited = [False] * len(self.adj)",
            "\t\tstack = [start]",
            "\t\twhile stack:",
            "\t\t\tstart = stack[-1]",
            "\t\t\tif not visited[start]:",
            "\t\t\t\tvisited[start] = True",
            "\t\t\t\tfor child in self.adj[start]:",
            "\t\t\t\t\tif not visited[child]:",
            "\t\t\t\t\t\tself.parent[child] = start",
            "\t\t\t\t\t\tself.depth[child] = self.depth[start]+1",
            "\t\t\t\t\t\tstack.append(child)",
            "\t\t\telse:",
            "\t\t\t\tself.size[stack.pop()] = 1",
            "\t\t\t\tk = 0",
            "\t\t\t\tfor child in self.adj[start]:",
            "\t\t\t\t\tif self.parent[start]!=child:",
            "\t\t\t\t\t\tself.size[start] += self.size[child]",
            "\t\t\t\t\t\tif self.size[child]>k:",
            "\t\t\t\t\t\t\tk = self.size[child]",
            "\t\t\t\t\t\t\tself.heavy[start] = child",
            "\t\treturn visited",
            "\tdef _decompose(self, root):",
            "\t\tstack = [(root,root)]",
            "\t\ttime = 0",
            "\t\twhile stack:",
            "\t\t\tu, h = stack.pop()",
            "\t\t\tself.head[u] = h",
            "\t\t\tself.flat[time] = u",
            "\t\t\tself.pos[u] = time",
            "\t\t\ttime += 1",
            "\t\t\tfor v in reversed(self.adj[u]):",
            "\t\t\t\tif v!=self.parent[u] and v!=self.heavy[u]:",
            "\t\t\t\t\tstack.append((v, v))",
            "\t\t\tif self.heavy[u] != -1:",
            "\t\t\t\tstack.append((self.heavy[u], h))",
            "\tdef query(self, u, v):",
            "\t\tres = self.unit",
            "\t\twhile self.head[u] != self.head[v]:",
            "\t\t\tif self.depth[self.head[u]] < self.depth[self.head[v]]:",
            "\t\t\t\tu, v = v, u",
            "\t\t\tres = self.func(res, self.seg.query(self.pos[self.head[u]], self.pos[u] + 1))",
            "\t\t\tu = self.parent[self.head[u]]",
            "\t\tif self.depth[u] > self.depth[v]:",
            "\t\t\tu, v = v, u",
            "\t\treturn self.func(res, self.seg.query(self.pos[u], self.pos[v] + 1))",
            "\tdef update(self, u, value):",
            "\t\tself.seg.update(self.pos[u], value)",
            "\tdef update_path(self, u, v, value):",
            "\t\twhile self.head[u] != self.head[v]:",
            "\t\t\tif self.depth[self.head[u]] < self.depth[self.head[v]]:",
            "\t\t\t\tu, v = v, u",
            "\t\t\tself.seg.range_update(self.pos[self.head[u]], self.pos[u], value)",
            "\t\t\tu = self.parent[self.head[u]]",
            "\t\tif self.depth[u] > self.depth[v]:",
            "\t\t\tu, v = v, u",
            "\t\tself.seg.range_update(self.pos[u], self.pos[v], value)",
            "\tdef add_to_subtree(self, u, value):",
            "\t\tself.seg.range_update(self.pos[u], self.pos[u] + self.size[u] - 1, value)"
        ],
        "description": "hld implementation"
    },
    "BitArray": {
        "prefix": "bitarray",
        "body": [
            "class BitSet:",
            "\tADDRESS_BITS_PER_WORD = 12",
            "\tBITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD",
            "\tWORD_MASK = -1",
            "\tdef __init__(self, sz):",
            "\t\tself.sz = sz",
            "\t\tself.words = [0] * (self._wordIndex(sz - 1) + 1)",
            "\tdef _wordIndex(self, bitIndex):",
            "\t\tif bitIndex >= self.sz:",
            "\t\t\traise ValueError(\"out of bound index\", bitIndex)",
            "\t\treturn bitIndex >> BitSet.ADDRESS_BITS_PER_WORD",
            "\tdef flip(self, bitIndex):",
            "\t\twordIndex = self._wordIndex(bitIndex)",
            "\t\tself.words[wordIndex] ^= 1 << (bitIndex % BitSet.BITS_PER_WORD)",
            "\tdef flip_range(self, l, r):",
            "\t\tstartWordIndex = self._wordIndex(l)",
            "\t\tendWordIndex = self._wordIndex(r)",
            "\t\tfirstWordMask = BitSet.WORD_MASK << (l % BitSet.BITS_PER_WORD)",
            "\t\trem = (r+1) % BitSet.BITS_PER_WORD",
            "\t\tlastWordMask = BitSet.WORD_MASK if rem == 0 else ~(BitSet.WORD_MASK << rem)",
            "\t\tif startWordIndex == endWordIndex:",
            "\t\t\tself.words[startWordIndex] ^= (firstWordMask & lastWordMask)",
            "\t\telse:",
            "\t\t\tself.words[startWordIndex] ^= firstWordMask",
            "\t\t\tfor i in range(startWordIndex + 1, endWordIndex):",
            "\t\t\t\tself.words[i] ^= BitSet.WORD_MASK",
            "\t\t\tself.words[endWordIndex] ^= lastWordMask",
            "\tdef __setitem__(self, bitIndex, value):",
            "\t\twordIndex = self._wordIndex(bitIndex)",
            "\t\tif value:",
            "\t\t\tself.words[wordIndex] |= 1 << (bitIndex % BitSet.BITS_PER_WORD)",
            "\t\telse:",
            "\t\t\tself.words[wordIndex] &= ~(1 << (bitIndex % BitSet.BITS_PER_WORD))",
            "\tdef __getitem__(self, bitIndex):",
            "\t\twordIndex = self._wordIndex(bitIndex)",
            "\t\treturn self.words[wordIndex] & (1 << (bitIndex % BitSet.BITS_PER_WORD)) != 0",
            "\tdef nextSetBit(self, fromIndex):",
            "\t\twordIndex = self._wordIndex(fromIndex)",
            "\t\tword = self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))",
            "",
            "\t\twhile True:",
            "\t\t\tif word != 0:",
            "\t\t\t\treturn wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1",
            "\t\t\twordIndex += 1",
            "\t\t\tif wordIndex > len(self.words) - 1:",
            "\t\t\t\treturn -1",
            "\t\t\tword = self.words[wordIndex]",
            "\tdef nextClearBit(self, fromIndex):",
            "\t\twordIndex = self._wordIndex(fromIndex)",
            "\t\tword = ~self.words[wordIndex] & (BitSet.WORD_MASK << (fromIndex % BitSet.BITS_PER_WORD))",
            "",
            "\t\twhile True:",
            "\t\t\tif word != 0:",
            "\t\t\t\tindex = wordIndex * BitSet.BITS_PER_WORD + (word & -word).bit_length() - 1",
            "\t\t\t\treturn index if index < self.sz else - 1",
            "\t\t\twordIndex += 1",
            "\t\t\tif wordIndex > len(self.words) - 1:",
            "\t\t\t\treturn -1",
            "\t\t\tword = ~self.words[wordIndex]",
            "\tdef lastSetBit(self):",
            "\t\twordIndex = len(self.words) - 1",
            "\t\tword = self.words[wordIndex]",
            "",
            "\t\twhile wordIndex >= 0:",
            "\t\t\tif word != 0:",
            "\t\t\t\treturn wordIndex * BitSet.BITS_PER_WORD + (word.bit_length() - 1 if word > 0 else  BitSet.BITS_PER_WORD - 1)",
            "\t\t\twordIndex -= 1",
            "\t\t\tword = self.words[wordIndex]",
            "\t\treturn -1",
            "\tdef __str__(self):",
            "\t\tres = []",
            "\t\tst = 0",
            "\t\twhile True:",
            "\t\t\ti = self.nextSetBit(st)",
            "\t\t\tif i != -1:",
            "\t\t\t\tres += [0] * (i - st)",
            "\t\t\t\tj = self.nextClearBit(i)",
            "\t\t\t\tif j != -1:",
            "\t\t\t\t\tres += [1] * (j-i)",
            "\t\t\t\t\tst = j",
            "\t\t\t\telse:",
            "\t\t\t\t\tres += [1] * (self.sz - i)",
            "\t\t\t\t\tbreak",
            "\t\t\telse:",
            "\t\t\t\tres += [0] * (self.sz - st)",
            "\t\t\t\tbreak",
            "",
            "\t\treturn \"\".join(str(v) for v in res)",
            "\tdef __repr__(self):",
            "\t\treturn \"Bitset(%s)\" % str(self)",
            "\tdef __iter__(self):",
            "\t\tfor i in self[:]:",
            "\t\t\tyield i",
            "\tdef __len__(self):",
            "\t\treturn self.sz",
            "\tdef add(self, val):",
            "\t\tself.flip_range(val, self.nextClearBit(val))",
            "\tdef rem(self, val):",
            "\t\tself.flip_range(val, self.nextSetBit(val))"
        ],
        "description": "BitArray implementation"
    },
    
    "graphadv": {
        "prefix": "graphadv",
        "body": [
            "INF = float(\"inf\")",
            "class Dinic:",
            "\tdef __init__(self, n):",
            "\t\tself.lvl = [0] * n",
            "\t\tself.ptr = [0] * n",
            "\t\tself.q = [0] * n",
            "\t\tself.adj = [[] for _ in range(n)]",
            "\tdef add_edge(self, a, b, c, rcap=0):",
            "\t\tself.adj[a].append([b, len(self.adj[b]), c, 0])",
            "\t\tself.adj[b].append([a, len(self.adj[a]) - 1, rcap, 0])",
            "\tdef dfs(self, v, t, f):",
            "\t\tif v == t or not f:",
            "\t\t\treturn f",
            "\t\tfor i in range(self.ptr[v], len(self.adj[v])):",
            "\t\t\te = self.adj[v][i]",
            "\t\t\tif self.lvl[e[0]] == self.lvl[v] + 1:",
            "\t\t\t\tp = self.dfs(e[0], t, min(f, e[2] - e[3]))",
            "\t\t\t\tif p:",
            "\t\t\t\t\tself.adj[v][i][3] += p",
            "\t\t\t\t\tself.adj[e[0]][e[1]][3] -= p",
            "\t\t\t\t\treturn p",
            "\t\t\tself.ptr[v] += 1",
            "\t\treturn 0",
            "\tdef calc(self, s, t):",
            "\t\tflow, self.q[0] = 0, s",
            "\t\tfor l in range(31):  # l = 30 maybe faster for random data",
            "\t\t\twhile True:",
            "\t\t\t\tself.lvl, self.ptr = [0] * len(self.q), [0] * len(self.q)",
            "\t\t\t\tqi, qe, self.lvl[s] = 0, 1, 1",
            "\t\t\t\twhile qi < qe and not self.lvl[t]:",
            "\t\t\t\t\tv = self.q[qi]",
            "\t\t\t\t\tqi += 1",
            "\t\t\t\t\tfor e in self.adj[v]:",
            "\t\t\t\t\t\tif not self.lvl[e[0]] and (e[2] - e[3]) >> (30 - l):",
            "\t\t\t\t\t\t\tself.q[qe] = e[0]",
            "\t\t\t\t\t\t\tqe += 1",
            "\t\t\t\t\t\t\tself.lvl[e[0]] = self.lvl[v] + 1",
            "\t\t\t\tp = self.dfs(s, t, INF)",
            "\t\t\t\twhile p:",
            "\t\t\t\t\tflow += p",
            "\t\t\t\t\tp = self.dfs(s, t, INF)",
            "\t\t\t\tif not self.lvl[t]:",
            "\t\t\t\t\tbreak",
            "\t\treturn flow",
            "",
            "class binary_lift:",
            "\tdef __init__(self, graph, data=(), f=min, root=0):",
            "\t\tn = len(graph)",
            "\t\tparent = [-1] * (n + 1)",
            "\t\tdepth = self.depth = [-1] * n",
            "\t\tbfs = [root]",
            "\t\tdepth[root] = 0",
            "\t\tfor node in bfs:",
            "\t\t\tfor nei in graph[node]:",
            "\t\t\t\tif depth[nei] == -1:",
            "\t\t\t\t\tparent[nei] = node",
            "\t\t\t\t\tdepth[nei] = depth[node] + 1",
            "\t\t\t\t\tbfs.append(nei)",
            "\t\tdata = self.data = [data]",
            "\t\tparent = self.parent = [parent]",
            "\t\tself.f = f",
            "\t\tfor _ in range(max(depth).bit_length()):",
            "\t\t\told_data = data[-1]",
            "\t\t\told_parent = parent[-1]",
            "\t\t\tdata.append([f(val, old_data[p]) for val,p in zip(old_data, old_parent)])",
            "\t\t\tparent.append([old_parent[p] for p in old_parent])",
            "\tdef lca(self, a, b):",
            "\t\tdepth = self.depth",
            "\t\tparent = self.parent",
            "\t\tif depth[a] < depth[b]:",
            "\t\t\ta,b = b,a",
            "\t\td = depth[a] - depth[b]",
            "\t\tfor i in range(d.bit_length()):",
            "\t\t\tif (d >> i) & 1:",
            "\t\t\t\ta = parent[i][a]",
            "\t\tfor i in range(depth[a].bit_length())[::-1]:",
            "\t\t\tif parent[i][a] != parent[i][b]:",
            "\t\t\t\ta = parent[i][a]",
            "\t\t\t\tb = parent[i][b]",
            "\t\tif a != b:",
            "\t\t\treturn parent[0][a]",
            "\t\telse:",
            "\t\t\treturn a",
            "\tdef distance(self, a, b):",
            "\t\treturn self.depth[a] + self.depth[b] - 2 * self.depth[self.lca(a,b)]",
            "\tdef kth_ancestor(self, a, k):",
            "\t\tparent = self.parent",
            "\t\tif self.depth[a] < k:",
            "\t\t\treturn -1",
            "\t\tfor i in range(k.bit_length()):",
            "\t\t\tif (k >> i) & 1:",
            "\t\t\t\ta = parent[i][a]",
            "\t\treturn a",
            "\tdef __call__(self, a, b):",
            "\t\tdepth = self.depth",
            "\t\tparent = self.parent",
            "\t\tdata = self.data",
            "\t\tf = self.f",
            "\t\tc = self.lca(a, b)",
            "\t\tval = data[0][c]",
            "\t\tfor x,d in (a, depth[a] - depth[c]), (b, depth[b] - depth[c]):",
            "\t\t\tfor i in range(d.bit_length()):",
            "\t\t\t\tif (d >> i) & 1:",
            "\t\t\t\t\tval = f(val, data[i][x])",
            "\t\t\t\t\tx = parent[i][x]",
            "\t\treturn val"
        ],
        "description": "graphadv implementation"
    },
    
    "2sat": {
        "prefix": "2sat",
        "body": [
            "def kahn(graph):",
            "\tn = len(graph)",
            "\tindeg, idx = [0] * n, [0] * n",
            "\tfor i in range(n):",
            "\t\tfor e in graph[i]:",
            "\t\t\tindeg[e] += 1",
            "\tq, res = [], []",
            "\tfor i in range(n):",
            "\t\tif indeg[i] == 0:",
            "\t\t\tq.append(i)",
            "\tnr = 0",
            "\twhile q:",
            "\t\tres.append(q.pop())",
            "\t\tidx[res[-1]], nr = nr, nr + 1",
            "\t\tfor e in graph[res[-1]]:",
            "\t\t\tindeg[e] -= 1",
            "\t\t\tif indeg[e] == 0:",
            "\t\t\t\tq.append(e)",
            "\treturn res, idx, nr == n",
            "",
            "def find_SCC(graph):",
            "\tSCC, S, P = [], [], []",
            "\tdepth = [0] * len(graph)",
            "\tstack = list(range(len(graph)))",
            "\twhile stack:",
            "\t\tnode = stack.pop()",
            "\t\tif node < 0:",
            "\t\t\td = depth[~node] - 1",
            "\t\t\tif P[-1] > d:",
            "\t\t\t\tSCC.append(S[d:])",
            "\t\t\t\tdel S[d:], P[-1]",
            "\t\t\t\tfor node in SCC[-1]:",
            "\t\t\t\t\tdepth[node] = -1",
            "\t\telif depth[node] > 0:",
            "\t\t\twhile P[-1] > depth[node]:",
            "\t\t\t\tP.pop()",
            "\t\telif depth[node] == 0:",
            "\t\t\tS.append(node)",
            "\t\t\tP.append(len(S))",
            "\t\t\tdepth[node] = len(S)",
            "\t\t\tstack.append(~node)",
            "\t\t\tstack += graph[node]",
            "\treturn SCC[::-1]",
            "",
            "class TwoSat:",
            "\tdef __init__(self, n):",
            "\t\tself.n = n",
            "\t\tself.graph = [[] for _ in range(2 * n)]",
            "\tdef negate(self, x):",
            "\t\treturn x+self.n if x<self.n else x-self.n",
            "\tdef _imply(self, x, y):",
            "\t\t# agar x hoga , toh y hoga",
            "\t\tself.graph[x].append(y)",
            "\t\tself.graph[self.negate(y)].append(self.negate(x))",
            "\tdef either(self, x, y):",
            "\t\t# koi ek true ho sakta hain ya dono bhi",
            "\t\tself._imply(self.negate(x),y)",
            "\t\tself._imply(self.negate(y),x)",
            "\tdef set(self, x):",
            "\t\tself._imply(self.negate(x),x)",
            "\tdef solve(self):",
            "\t\tSCC = find_SCC(self.graph)",
            "\t\torder = [0] * (2 * self.n)",
            "\t\tfor i, comp in enumerate(SCC):",
            "\t\t\tfor x in comp:",
            "\t\t\t\torder[x] = i",
            "\t\tfor i in range(self.n):",
            "\t\t\tif order[i] == order[self.negate(i)]:",
            "\t\t\t\treturn False, None",
            "\t\treturn True, [+(order[i] > order[self.negate(i)]) for i in range(self.n)]"
        ],
        "description": "2sat implementation"
    },
    "graphflatten": {
        "prefix": "graphflatten",
        "body": [
            "class UnionFind:",
            "\tdef __init__(self, n):",
            "\t\tself.parent = list(range(n))",
            "\tdef find(self, a):",
            "\t\tacopy = a",
            "\t\twhile a != self.parent[a]:",
            "\t\t\ta = self.parent[a]",
            "\t\twhile acopy != a:",
            "\t\t\tself.parent[acopy], acopy = a, self.parent[acopy]",
            "\t\treturn a",
            "\tdef merge(self, a, b):",
            "\t\tself.parent[self.find(b)] = self.find(a)",
            "",
            "def kruskal(edges,n=None):",
            "\tif not n:",
            "\t\tn = len(edges)+1",
            "\tedges = sorted(edges,key=lambda x:x[2])",
            "\tunion = UnionFind(n)",
            "\tans = []",
            "\tval = 0",
            "\tfor u,v,w in edges:",
            "\t\tt = union.find(u)",
            "\t\tt1 = union.find(v)",
            "\t\tif t!=t1:",
            "\t\t\tval += w",
            "\t\t\tunion.parent[t1] = t",
            "\t\t\tans.append((u,v,w))",
            "\treturn ans,val",
            "",
            "def dfs(graph):",
            "\tstarttime = [[0,0] for i in range(len(graph))]",
            "\ttime = 0",
            "\tstack = [(0,-1,0)]",
            "\twhile stack:",
            "\t\tcur, prev, state = stack.pop()",
            "\t\tif state == 0:",
            "\t\t\tstarttime[cur][0] = time",
            "\t\t\ttime += 1",
            "\t\t\tstack.append((cur, prev, 1))",
            "\t\t\tfor neighbor in graph[cur]:",
            "\t\t\t\tif neighbor == prev:",
            "\t\t\t\t\tcontinue",
            "\t\t\t\tstack.append((neighbor, cur, 0))",
            "\t\telif state == 1:",
            "\t\t\tstarttime[cur][1] = time",
            "\treturn starttime",
            "",
            "def is_bipartite(graph):",
            "\tn = len(graph)",
            "\tcolor = [-1] * n",
            "\tfor start in range(n):",
            "\t\tif color[start] == -1:",
            "\t\t\tcolor[start] = 0",
            "\t\t\tstack = [start]",
            "\t\t\twhile stack:",
            "\t\t\t\tparent = stack.pop()",
            "\t\t\t\tfor child in graph[parent]:",
            "\t\t\t\t\tif color[child] == -1:",
            "\t\t\t\t\t\tcolor[child] = 1 - color[parent]",
            "\t\t\t\t\t\tstack.append(child)",
            "\t\t\t\t\telif color[parent] == color[child]:",
            "\t\t\t\t\t\treturn False, color",
            "\treturn True, color"
        ],
        "description": "graphflatten implementation"
    },
    "Graphoth": {
        "prefix": "graphoth",
        "body": [
            "def euler_path(d):",
            "\tstart = [1]",
            "\tans = []",
            "\twhile start:",
            "\t\tcur = start[-1]",
            "\t\tif len(d[cur])==0:",
            "\t\t\tans.append(cur)",
            "\t\t\tstart.pop()",
            "\t\t\tcontinue",
            "\t\tk1 = d[cur].pop()",
            "\t\td[k1].remove(cur)",
            "\t\tstart.append(k1)",
            "\treturn ans",
            "",
            "def floyd_warshall(n, edges):",
            "\tdist = [[0 if i == j else float(\"inf\") for i in range(n)] for j in range(n)]",
            "\tpred = [[None] * n for _ in range(n)]",
            "",
            "\tfor u, v, d in edges:",
            "\t\tdist[u][v] = d",
            "\t\tpred[u][v] = u",
            "",
            "\tfor k in range(n):",
            "\t\tfor i in range(n):",
            "\t\t\tfor j in range(n):",
            "\t\t\t\tif dist[i][k] + dist[k][j] < dist[i][j]:",
            "\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j]",
            "\t\t\t\t\tpred[i][j] = pred[k][j]",
            "\t# Sanity Check",
            "\t# for u, v, d in edges:",
            "\t#\t if dist[u] + d < dist[v]:",
            "\t#\t\t return None",
            "\treturn dist, pred",
            "",
            "def bellman_ford(n, edges, start=0):",
            "\tdist = [float(\"inf\")] * n",
            "\tpred = [None] * n",
            "\tdist[start] = 0",
            "\tfor _ in range(n):",
            "\t\tfor u, v, d in edges:",
            "\t\t\tif dist[u] + d < dist[v]:",
            "\t\t\t\tdist[v] = dist[u] + d",
            "\t\t\t\tpred[v] = u",
            "\t# for u, v, d in edges:",
            "\t#\t if dist[u] + d < dist[v]:",
            "\t#\t\t return -1",
            "\t# This returns -1 , if there is a negative cycle",
            "",
            "def toposort(graph):",
            "\tres, found = [], [0] * len(graph)",
            "\tstack = list(range(len(graph)))",
            "\twhile stack:",
            "\t\tnode = stack.pop()",
            "\t\tif node < 0:",
            "\t\t\tres.append(~node)",
            "\t\telif not found[node]:",
            "\t\t\tfound[node] = 1",
            "\t\t\tstack.append(~node)",
            "\t\t\tstack += graph[node]",
            "\tfor node in res:",
            "\t\tif any(found[nei] for nei in graph[node]):",
            "\t\t\treturn None",
            "\t\tfound[node] = 0",
            "\treturn res[::-1]"
        ],
        "description": "Graphoth implementation"
    },
    "graph": {
        "prefix": "graph",
        "body": [
            "def bfsf(d,start=0):",
            "\tbfs = [start]",
            "\tvisited = [False]*(len(d))",
            "\tvisited[start] = True",
            "\tfor u in bfs:",
            "\t\tfor j in d[u]:",
            "\t\t\tif visited[j]:",
            "\t\t\t\tcontinue",
            "\t\t\tvisited[j] = True",
            "\t\t\tbfs.append(j)",
            "\treturn bfs",
            "",
            "def dfs(d,start=0):",
            "\t# I can also use this to replicate recursion",
            "\t# without facing the overhead",
            "\tn = len(d)",
            "\tvisited = [False]*n",
            "\tdp = [0]*n",
            "\tfinished = [False]*n",
            "\tstack = [start]",
            "\twhile stack:",
            "\t\tstart = stack[-1]",
            "\t\t# stack.pop() # use this if there is nothing after returning",
            "\t\tif not visited[start]:",
            "\t\t\tvisited[start] = True",
            "\t\t\tfor child in d[start]:",
            "\t\t\t\tif not visited[child]:",
            "\t\t\t\t\tstack.append(child)",
            "\t\telse:",
            "\t\t\tstack.pop()",
            "\t\t\tdp[start] += 1",
            "\t\t\tfor child in d[start]:",
            "\t\t\t\tif finished[child]:",
            "\t\t\t\t\tdp[start] += dp[child]",
            "\t\t\tfinished[start] = True",
            "\t\t\t# remove else if you are doing nothing here",
            "\t\t\t# add the stuff that you do post traversel here",
            "\t\t\t# and add the finished array",
            "\treturn dp",
            "",
            "def dijkstra(d,start=0):",
            "\tn = len(d)",
            "\tdist = [float(\"inf\")]*n",
            "\t# parents = [-1]*n",
            "\tdist[start] = 0",
            "\tqueue = [(0, start)]",
            "\twhile queue:",
            "\t\tpath_len, v = heappop(queue)",
            "\t\tif path_len == dist[v]:",
            "\t\t\tfor w, edge_len in d[v]:",
            "\t\t\t\tnew_dist = edge_len+path_len",
            "\t\t\t\tif new_dist<dist[w]:",
            "\t\t\t\t\tdist[w] = new_dist",
            "\t\t\t\t\t# parents[w] = v",
            "\t\t\t\t\theappush(queue, (new_dist, w))",
            "\treturn dist"
        ],
        "description": "graph implementation"
    },
    "dfsin": {
        "prefix": "dfsin",
        "body": [
            "n = len(gr)",
            "visited = [False]*n",
            "finished = [False]*n",
            "stack = [0]",
            "while stack:",
            "\tstart = stack[-1]",
            "\tif not visited[start]:",
            "\t\tvisited[start] = True",
            "\t\tfor child in gr[start]:",
            "\t\t\tif not visited[child]:",
            "\t\t\t\tstack.append(child)",
            "\telse:",
            "\t\tstack.pop()",
            "\t\tfor child in gr[start]:",
            "\t\t\tif finished[child]:",
            "\t\t\t\t# perform the post rec operations here",
            "\t\t\t\tpass",
            "\t\tfinished[start] = True"
        ],
        "description": "dfsin implementation"
    },
    "utils": {
        "prefix": "utils",
        "body": [
            "def extras():",
            "\tgetcontext().prec = 50",
            "\tsys.setrecursionlimit(10**6)",
            "\tsys.set_int_max_str_digits(10**5)",
            "# extras()",
            "",
            "def interactive():",
            "\timport builtins",
            "\t# print(globals())",
            "\tglobals()['print'] = lambda *args, **kwargs: builtins.print(*args, flush=True, **kwargs)",
            "# interactive()",
            "",
            "def GI(n,m=None,sub=-1,dirs=False,weight=False):",
            "\tif m==None:",
            "\t\tm = n-1",
            "\td = [[] for i in range(n)]",
            "\tif not weight:",
            "\t\tfor i in range(m):",
            "\t\t\tu,v = LII_C(lambda x:int(x)+sub)",
            "\t\t\td[u].append(v)",
            "\t\t\tif not dirs:",
            "\t\t\t\td[v].append(u)",
            "\telse:",
            "\t\tfor i in range(m):",
            "\t\t\tu,v,w = LII()",
            "\t\t\td[u+sub].append((v+sub,w))",
            "\t\t\tif not dirs:",
            "\t\t\t\td[v+sub].append((u+sub,w))",
            "\treturn d",
            "",
            "ordalp = lambda s : ord(s)-65 if s.isupper() else ord(s)-97",
            "alp = lambda x : chr(97+x)",
            "yes = lambda : print(\"Yes\")",
            "no = lambda : print(\"No\")",
            "yn = lambda flag : print(\"Yes\" if flag else \"No\")",
            "printf = lambda x : print(-1 if x==float('inf') else x)",
            "lalp = 'abcdefghijklmnopqrstuvwxyz'",
            "ualp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'",
            "dirs = ((1,0),(0,1),(-1,0),(0,-1))",
            "dirs8 = ((1,0),(0,1),(-1,0),(0,-1),(1,-1),(-1,1),(1,1),(-1,-1))",
            "ldir = {'D':(1,0),'U':(-1,0),'R':(0,1),'L':(0,-1)}"
        ],
        "description": "utils implementation"
    },
    "perdsu": {
        "prefix": "perdsu",
        "body": [
            "class PersistentDSU:",
            "\tdef __init__(self,n):",
            "\t\tself.parent = list(range(n))",
            "\t\tself.size = [1]*n",
            "\t\tself.time = [float('inf')]*n",
            "\tdef find(self,node,version):",
            "\t\t# returns root at given version",
            "\t\twhile not (self.parent[node]==node or self.time[node]>version):",
            "\t\t\tnode = self.parent[node]",
            "\t\treturn node",
            "\tdef union(self,a,b,time):",
            "\t\t# merges a and b",
            "\t\ta = self.find(a,time)",
            "\t\tb = self.find(b,time)",
            "\t\tif a==b:",
            "\t\t\treturn False",
            "\t\tif self.size[a]>self.size[b]:",
            "\t\t\ta,b = b,a",
            "\t\tself.parent[a] = b",
            "\t\tself.time[a] = time",
            "\t\tself.size[b] += self.size[a]",
            "\t\treturn True",
            "\tdef isconnected(self,a,b,time):",
            "\t\treturn self.find(a,time)==self.find(b,time)"
        ],
        "description": "perdsu implementation"
    },
    "sorttree": {
        "prefix": "sorttree",
        "body": [
            "class MergeSortTree:",
            "\t@staticmethod",
            "\tdef merge(a, b):",
            "\t\t# Change this function depending upon needs",
            "\t\tL = []",
            "\t\ti = 0",
            "\t\tj = 0",
            "\t\twhile i<len(a) and j<len(b):",
            "\t\t\tif a[i]<b[j]:",
            "\t\t\t\tL.append(a[i])",
            "\t\t\t\ti += 1",
            "\t\t\telse:",
            "\t\t\t\tL.append(b[j])",
            "\t\t\t\tj += 1",
            "\t\twhile i<len(a):",
            "\t\t\tL.append(a[i])",
            "\t\t\ti += 1",
            "\t\twhile j<len(b):",
            "\t\t\tL.append(b[j])",
            "\t\t\tj += 1",
            "\t\treturn L",
            "\t@staticmethod",
            "\tdef op(a,b):",
            "\t\treturn a+b",
            "\t@staticmethod",
            "\tdef func(L,l,r):",
            "\t\treturn bisect_right(L,r)-bisect_left(L,l)",
            "\tdef __init__(self, data):",
            "\t\tself.n = len(data)",
            "\t\tself.tree = [0] * (2 * self.n)",
            "\t\tself.build(data)",
            "\tdef build(self, data):",
            "\t\tfor i in range(self.n):",
            "\t\t\tself.tree[self.n + i] = [data[i]]",
            "\t\tfor i in range(self.n - 1, 0, -1):",
            "\t\t\tself.tree[i] = self.merge(self.tree[i * 2], self.tree[i * 2 + 1])",
            "\tdef update(self, pos, value):",
            "\t\t# Update the value at the leaf node",
            "\t\tpos += self.n",
            "\t\t# For updating",
            "\t\tself.tree[pos] = [value]",
            "\t\t# self.tree[pos][0] += value",
            "\t\t# If you want to add rather than update",
            "\t\twhile pos > 1:",
            "\t\t\tpos //= 2",
            "\t\t\tself.tree[pos] = self.merge(self.tree[2 * pos], self.tree[2 * pos + 1])",
            "\tdef query(self, left, right, l, r):",
            "\t\t# Query the maximum value in the range [left, right)",
            "\t\tleft += self.n",
            "\t\tright += self.n",
            "\t\t# Change the initializer depending upon the self.func",
            "\t\tmax_val = 0",
            "\t\t##",
            "\t\twhile left < right:",
            "\t\t\tif left % 2:",
            "\t\t\t\tmax_val = self.op(max_val,self.func(self.tree[left],l,r))",
            "\t\t\t\tleft += 1",
            "\t\t\tif right % 2:",
            "\t\t\t\tright -= 1",
            "\t\t\t\tmax_val = self.op(max_val,self.func(self.tree[right],l,r))",
            "\t\t\tleft //= 2",
            "\t\t\tright //= 2",
            "\t\treturn max_val"
        ],
        "description": "Merge Sort Tree implementation"
    },
    "2DBIT": {
        "prefix": "2dbit",
        "body": [
            "class BIT2D:",
            "\tdef __init__(self, arr):",
            "\t\tself.n = len(arr)",
            "\t\tself.m = len(arr[0]) if self.n > 0 else 0",
            "\t\t# self.bit = [row[:] for row in arr]",
            "\t\tself.bit = arr # assuming that arr is not used after this",
            "\t\tfor i in range(self.n):",
            "\t\t\tfor j in range(self.m):",
            "\t\t\t\tni = i | (i + 1)",
            "\t\t\t\tif ni < self.n:",
            "\t\t\t\t\tself.bit[ni][j] += self.bit[i][j]",
            "\t\tfor i in range(self.n):",
            "\t\t\tfor j in range(self.m):",
            "\t\t\t\tnj = j | (j + 1)",
            "\t\t\t\tif nj < self.m:",
            "\t\t\t\t\tself.bit[i][nj] += self.bit[i][j]",
            "\tdef add(self, x, y, delta):",
            "\t\t# 0-based in log n * log m",
            "\t\ti = x",
            "\t\twhile i < self.n:",
            "\t\t\tj = y",
            "\t\t\twhile j < self.m:",
            "\t\t\t\tself.bit[i][j] += delta",
            "\t\t\t\tj |= j + 1",
            "\t\t\ti |= i + 1",
            "\tdef sum(self, x, y):",
            "\t\t# sum from 0,0 to x,y inclusive in log n * log m",
            "\t\tif not (0<=x<self.n) or not (0<=y<self.m):",
            "\t\t\treturn 0",
            "\t\tres = 0",
            "\t\ti = x",
            "\t\twhile i >= 0:",
            "\t\t\tj = y",
            "\t\t\twhile j >= 0:",
            "\t\t\t\tres += self.bit[i][j]",
            "\t\t\t\tj = (j & (j + 1)) - 1",
            "\t\t\ti = (i & (i + 1)) - 1",
            "\t\treturn res",
            "\tdef query(self, x1, y1, x2, y2):",
            "\t\t# sum of L[x1:x2+1][y1:y2+1]",
            "\t\treturn (self.sum(x2,y2)-self.sum(x1-1,y2)-self.sum(x2,y1-1)+(self.sum(x1-1,y1-1)))"
        ],
        "description": "2DBIT implementation"
    }
}